
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for OpenGL_Bridge.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.7.0
//* Generated on: Feb. 07, 2014 04:02:07 PM, (user: markca)
//* Automatically merged on: Feb. 07, 2014 04:03:52 PM, (user: markca)
//*>



#include "OpenGL_Bridge_pv.h"

#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
OpenGL_Bridge_pv::OpenGL_Bridge_pv(sc_module_name module_name) 
  : OpenGL_Bridge_pv_base(module_name) {
}    

void*
OpenGL_Bridge_pv::getHostMemory(unsigned int inputAdr) {
  tlm::tlm_dmi dmi_data;
  if(master_get_direct_memory_ptr(tlm::TLM_WRITE_COMMAND, 
                                      (mb_address_type) inputAdr,
                                      dmi_data)) {

    unsigned char* dmi_ptr = dmi_data.get_dmi_ptr();
    sc_dt::uint64 gpu_zero = inputAdr;
    return(dmi_ptr + (gpu_zero - dmi_data.get_start_address()));
  }
  return 0;
}

// Read callback for slave port.
// Returns true when successful.
bool OpenGL_Bridge_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

#define OPENGL_IOBASE		0x00000000
OPENGL_MMIO *opengl = (OPENGL_MMIO*) OPENGL_IOBASE;

// Write callback for slave port.
// Returns true when successful.
bool OpenGL_Bridge_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  
  if(address < (mb_address_type) &(opengl->sdl2Open)) {
    memcpy((char*) &args + address, data, 4);
  }
  else if(address == (mb_address_type) &(opengl->sdl2Open)) {
      sdl2Open();
  }
  else if(address == (mb_address_type) &(opengl->sdl2Swap)) {
      sdl2Swap();
  }
  else if(address == (mb_address_type) &(opengl->sdl2Close)) {
      sdl2Close();
  }
  else if(address == (mb_address_type) &(opengl->glBegin)) {
      bglBegin();
  }
  else if(address == (mb_address_type) &(opengl->glCallList)) {
      bglCallList();
  }
  else if(address == (mb_address_type) &(opengl->glClear)) {
      bglClear();
  }
  else if(address == (mb_address_type) &(opengl->glClearColor)) {
      bglClearColor();
  }
  else if(address == (mb_address_type) &(opengl->glColor3f)) {
      bglColor3f();
  }
  else if(address == (mb_address_type) &(opengl->glDisable)) {
      bglDisable();
  }
  else if(address == (mb_address_type) &(opengl->glEnable)) {
      bglEnable();
  }
  else if(address == (mb_address_type) &(opengl->glEnd)) {
      bglEnd();
  }
  else if(address == (mb_address_type) &(opengl->glEndList)) {
      bglEndList();
  }
  else if(address == (mb_address_type) &(opengl->glFlush)) {
      bglFlush();
  }
  else if(address == (mb_address_type) &(opengl->glFrustum)) {
      bglFrustum();
  }
  else if(address == (mb_address_type) &(opengl->glGenLists)) {
      bglGenLists();
  }
  else if(address == (mb_address_type) &(opengl->glLightf)) {
      bglLightf();
  }
  else if(address == (mb_address_type) &(opengl->glLightfv)) {
      bglLightfv();
  }
  else if(address == (mb_address_type) &(opengl->glLoadIdentity)) {
      bglLoadIdentity();
  }
  else if(address == (mb_address_type) &(opengl->glMaterialfv)) {
      bglMaterialfv();
  }
  else if(address == (mb_address_type) &(opengl->glMatrixMode)) {
      bglMatrixMode();
  }
  else if(address == (mb_address_type) &(opengl->glNewList)) {
      bglNewList();
  }
  else if(address == (mb_address_type) &(opengl->glNormal3f)) {
      bglNormal3f();
  }
  else if(address == (mb_address_type) &(opengl->glOrtho)) {
      bglOrtho();
  }
  else if(address == (mb_address_type) &(opengl->glPolygonMode)) {
      bglPolygonMode();
  }
  else if(address == (mb_address_type) &(opengl->glPopMatrix)) {
      bglPopMatrix();
  }
  else if(address == (mb_address_type) &(opengl->glPushMatrix)) {
      bglPushMatrix();
  }
  else if(address == (mb_address_type) &(opengl->glRectf)) {
      bglRectf();
  }
  else if(address == (mb_address_type) &(opengl->glRotatef)) {
      bglRotatef();
  }
  else if(address == (mb_address_type) &(opengl->glScalef)) {
      bglScalef();
  }
  else if(address == (mb_address_type) &(opengl->glShadeModel)) {
      bglShadeModel();
  }
  else if(address == (mb_address_type) &(opengl->glTexCoord2f)) {
      bglTexCoord2f();
  }
  else if(address == (mb_address_type) &(opengl->glTranslatef)) {
      bglTranslatef();
  }
  else if(address == (mb_address_type) &(opengl->glVertex2f)) {
      bglVertex2f();
  }
  else if(address == (mb_address_type) &(opengl->glVertex3f)) {
      bglVertex3f();
  }
  else if(address == (mb_address_type) &(opengl->glViewport)) {
      bglViewport();
  }
  else {
    cout << "OpenGL_Bridge WARNING: address " << address << " is not implemented" << endl;
  }
  return true;
} 

unsigned OpenGL_Bridge_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned OpenGL_Bridge_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool OpenGL_Bridge_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void OpenGL_Bridge_pv::sdl2Open(void)
{
    Uint32 flags = SDL_WINDOW_SHOWN|SDL_WINDOW_OPENGL;

    int error = SDL_Init(SDL_INIT_VIDEO);
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    
    mainWindow = SDL_CreateWindow("OpenGL Bridge", SDL_WINDOWPOS_UNDEFINED, 
                                  SDL_WINDOWPOS_UNDEFINED, 640, 480, flags);
    mainGLContext = SDL_GL_CreateContext(mainWindow);

    sysCTime = sc_time_stamp();
    lastTicks = 0;
    fps = 0;
}

void OpenGL_Bridge_pv::sdl2Swap(void)
{
    SDL_Event event;  
    while(SDL_PollEvent(&event)) {
        switch(event.type) {               
            case SDL_KEYDOWN:
                sc_stop();
                break;
            
            case SDL_QUIT:
                sc_stop();
                break;
                
            default:
                break;
        } 
    } 

    // We print how many times we have executed this during 1 simulated second
    sc_time s1(1, SC_SEC);
    if(sc_time_stamp() > (sysCTime + s1)) {
      cout << "FPS (SystemC Simulated Time): " << std::dec << fps << endl;
      sysCTime = sc_time_stamp();
      fps = 0;
    }
    fps++;
    
    // Define the maximum number of frames we should display per second in HOST time
    int maxFramesPerSecond = 50; // This is in HOST time

    // Delay the host and the simulation time to keep things in sync
    int delay = 1000 / maxFramesPerSecond - SDL_GetTicks() + lastTicks;
    if(delay > 0) { 
        SDL_Delay(delay);
        wait(delay, SC_MS);
    }

    SDL_GL_SwapWindow(mainWindow);

    lastTicks = SDL_GetTicks();
}

void OpenGL_Bridge_pv::sdl2Close(void)
{ 
    SDL_GL_DeleteContext(mainGLContext);
    SDL_DestroyWindow(mainWindow);
    SDL_Quit();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void OpenGL_Bridge_pv::bglBegin() {
  glBegin((GLenum) args[0]); 
}

void OpenGL_Bridge_pv::bglCallList() {
  glCallList((GLuint) args[0]);
}

void OpenGL_Bridge_pv::bglClear() {
  glClear((GLbitfield) args[0]);
}

void OpenGL_Bridge_pv::bglClearColor() {
  glClearColor((GLclampf) args[0], (GLclampf) args[1], (GLclampf) args[2], (GLclampf) args[3]);
}

void OpenGL_Bridge_pv::bglColor3f() {
  glColor3f((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}

void OpenGL_Bridge_pv::bglDisable() {
  glDisable((GLenum) args[0]);
}

void OpenGL_Bridge_pv::bglEnable() {
  glEnable((GLenum) args[0]);
}

void OpenGL_Bridge_pv::bglEnd() {
  glEnd();
}

void OpenGL_Bridge_pv::bglEndList() {
  glEndList();
}

void OpenGL_Bridge_pv::bglFlush() {
  glFlush();
}

void OpenGL_Bridge_pv::bglFrustum() {
  glFrustum((GLdouble) args[0], (GLdouble) args[1], 
            (GLdouble) args[2], (GLdouble) args[3], 
            (GLdouble) args[4], (GLdouble) args[5]);
}

void OpenGL_Bridge_pv::bglGenLists() {
  GLuint list = glGenLists((GLsizei) args[0]);
}

void OpenGL_Bridge_pv::bglLightf() {
    glLightf((GLenum) args[0], (GLenum) args[1], (GLfloat) args[2]);
}

void OpenGL_Bridge_pv::bglLightfv() {
  const GLfloat* hostMem = (const GLfloat *) getHostMemory((unsigned int) args[2]);
  if(hostMem) {
    glLightfv((GLenum) args[0], (GLenum) args[1], hostMem);
  }
}

void OpenGL_Bridge_pv::bglLoadIdentity() {
  glLoadIdentity();
}

void OpenGL_Bridge_pv::bglMaterialfv() {
  const GLfloat* hostMem = (const GLfloat *) getHostMemory((unsigned int) args[2]);
  if(hostMem) {
    glMaterialfv((GLenum) args[0], (GLenum) args[1], hostMem);
  }
}

void OpenGL_Bridge_pv::bglMatrixMode() {
  glMatrixMode((GLenum) args[0]);
}

void OpenGL_Bridge_pv::bglNewList() {
  glNewList((GLuint) args[0], (GLenum) args[1]);
}

void OpenGL_Bridge_pv::bglNormal3f() {
  glNormal3f((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}
 
void OpenGL_Bridge_pv::bglOrtho() {
  glOrtho((GLdouble) args[0], (GLdouble) args[1], 
          (GLdouble) args[2], (GLdouble) args[3], 
          (GLdouble) args[4], (GLdouble) args[5]);
}

void OpenGL_Bridge_pv::bglPolygonMode() {
  glPolygonMode((GLenum) args[0], (GLenum) args[1]);
}

void OpenGL_Bridge_pv::bglPopMatrix() {
  glPopMatrix();
}

void OpenGL_Bridge_pv::bglPushMatrix() {
  glPushMatrix();
}

void OpenGL_Bridge_pv::bglRectf() {
  glRectf((GLfloat) args[0], (GLfloat) args[1], 
          (GLfloat) args[2], (GLfloat) args[3]);
}

void OpenGL_Bridge_pv::bglRotatef() {
  glRotatef((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2], (GLfloat) args[3]);
}

void OpenGL_Bridge_pv::bglScalef() {
  glScalef((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}

void OpenGL_Bridge_pv::bglShadeModel() {
  glShadeModel((GLenum) args[0]);
}

void OpenGL_Bridge_pv::bglTexCoord2f() {
  glTexCoord2f((GLfloat) args[0], (GLfloat) args[1]);
}

void OpenGL_Bridge_pv::bglTranslatef() {
  glTranslatef((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}

void OpenGL_Bridge_pv::bglVertex2f() {
  glVertex2f((GLfloat) args[0], (GLfloat) args[1]);
}

void OpenGL_Bridge_pv::bglVertex3f() {
  glVertex3f((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}

void OpenGL_Bridge_pv::bglViewport() {
  glViewport((GLint) args[0], (GLint) args[1], (GLsizei) args[2], (GLsizei) args[3]);
}

