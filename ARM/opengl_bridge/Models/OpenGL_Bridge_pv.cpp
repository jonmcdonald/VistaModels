
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for OpenGL_Bridge.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.7.0
//* Generated on: Feb. 07, 2014 04:02:07 PM, (user: markca)
//* Automatically merged on: Feb. 07, 2014 04:03:52 PM, (user: markca)
//*>



#include "OpenGL_Bridge_pv.h"

#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
OpenGL_Bridge_pv::OpenGL_Bridge_pv(sc_module_name module_name) 
  : OpenGL_Bridge_pv_base(module_name) {
}    

void*
OpenGL_Bridge_pv::getHostMemory(unsigned int inputAdr) {
  tlm::tlm_dmi dmi_data;
  if(master_get_direct_memory_ptr(tlm::TLM_WRITE_COMMAND, 
                                      (mb_address_type) inputAdr,
                                      dmi_data)) {

    unsigned char* dmi_ptr = dmi_data.get_dmi_ptr();
    sc_dt::uint64 gpu_zero = inputAdr;
    return(dmi_ptr + (gpu_zero - dmi_data.get_start_address()));
  }
  return 0;
}

// Read callback for slave port.
// Returns true when successful.
bool OpenGL_Bridge_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

#define OPENGL_IOBASE		0x00000000
OPENGL_MMIO *opengl = (OPENGL_MMIO*) OPENGL_IOBASE;

// Write callback for slave port.
// Returns true when successful.
bool OpenGL_Bridge_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  
  if(address < (mb_address_type) &(opengl->sdl2Open)) {
    memcpy((char*) &args + address, data, 4);
  }
  else if(address == (mb_address_type) &(opengl->sdl2Open)) {
      sdl2Open();
  }
  else if(address == (mb_address_type) &(opengl->sdl2Swap)) {
      sdl2Swap();
  }
  else if(address == (mb_address_type) &(opengl->sdl2Close)) {
      sdl2Close();
  }
  else if(address == (mb_address_type) &(opengl->glBegin)) {
      bglBegin();
  }
  else if(address == (mb_address_type) &(opengl->glCallList)) {
      bglCallList();
  }
  else if(address == (mb_address_type) &(opengl->glClear)) {
      bglClear();
  }
  else if(address == (mb_address_type) &(opengl->glColor3f)) {
      bglColor3f();
  }
  else if(address == (mb_address_type) &(opengl->glEnable)) {
      bglEnable();
  }
  else if(address == (mb_address_type) &(opengl->glEnd)) {
      bglEnd();
  }
  else if(address == (mb_address_type) &(opengl->glEndList)) {
      bglEndList();
  }
  else if(address == (mb_address_type) &(opengl->glFrustum)) {
      bglFrustum();
  }
  else if(address == (mb_address_type) &(opengl->glGenLists)) {
      bglGenLists();
  }
  else if(address == (mb_address_type) &(opengl->glLightfv)) {
      bglLightfv();
  }
  else if(address == (mb_address_type) &(opengl->glLoadIdentity)) {
      bglLoadIdentity();
  }
  else if(address == (mb_address_type) &(opengl->glMaterialfv)) {
      bglMaterialfv();
  }
  else if(address == (mb_address_type) &(opengl->glMatrixMode)) {
      bglMatrixMode();
  }
  else if(address == (mb_address_type) &(opengl->glNewList)) {
      bglNewList();
  }
  else if(address == (mb_address_type) &(opengl->glNormal3f)) {
      bglNormal3f();
  }
  else if(address == (mb_address_type) &(opengl->glOrtho)) {
      bglOrtho();
  }
  else if(address == (mb_address_type) &(opengl->glPopMatrix)) {
      bglPopMatrix();
  }
  else if(address == (mb_address_type) &(opengl->glPushMatrix)) {
      bglPushMatrix();
  }
  else if(address == (mb_address_type) &(opengl->glRectf)) {
      bglRectf();
  }
  else if(address == (mb_address_type) &(opengl->glRotatef)) {
      bglRotatef();
  }
  else if(address == (mb_address_type) &(opengl->glShadeModel)) {
      bglShadeModel();
  }
  else if(address == (mb_address_type) &(opengl->glTranslatef)) {
      bglTranslatef();
  }
  else if(address == (mb_address_type) &(opengl->glVertex3f)) {
      bglVertex3f();
  }
  else if(address == (mb_address_type) &(opengl->glViewport)) {
      bglViewport();
  }
  else {
    cout << "OpenGL_Bridge WARNING: address " << address << " is not implemented" << endl;
  }
  return true;
} 

unsigned OpenGL_Bridge_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned OpenGL_Bridge_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool OpenGL_Bridge_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void OpenGL_Bridge_pv::sdl2Open(void)
{
    Uint32 flags = SDL_WINDOW_SHOWN|SDL_WINDOW_OPENGL;

    int error = SDL_Init(SDL_INIT_VIDEO);
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    
    mainWindow = SDL_CreateWindow("OpenGL Bridge", SDL_WINDOWPOS_UNDEFINED, 
                                  SDL_WINDOWPOS_UNDEFINED, 640, 480, flags);
    mainGLContext = SDL_GL_CreateContext(mainWindow);
}

void OpenGL_Bridge_pv::sdl2Swap(void)
{
    SDL_Event event;  
    while(SDL_PollEvent(&event)) {
        switch(event.type) {               
            case SDL_KEYDOWN:
                sc_stop();
                break;
            
            case SDL_QUIT:
                sc_stop();
                break;
                
            default:
                break;
        } 
    } 

    SDL_GL_SwapWindow(mainWindow);
}

void OpenGL_Bridge_pv::sdl2Close(void)
{ 
    SDL_GL_DeleteContext(mainGLContext);
    SDL_DestroyWindow(mainWindow);
    SDL_Quit();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void OpenGL_Bridge_pv::bglBegin() {
  glBegin((GLenum) args[0]); 
}

void OpenGL_Bridge_pv::bglCallList() {
  glCallList((GLuint) args[0]);
}

void OpenGL_Bridge_pv::bglClear() {
  glClear((GLbitfield) args[0]);
}

void OpenGL_Bridge_pv::bglColor3f() {
  glColor3f((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}

void OpenGL_Bridge_pv::bglEnable() {
  glEnable((GLenum) args[0]);
}

void OpenGL_Bridge_pv::bglEnd() {
  glEnd();
}

void OpenGL_Bridge_pv::bglEndList() {
  glEndList();
}

void OpenGL_Bridge_pv::bglFrustum() {
  glFrustum((GLdouble) args[0], (GLdouble) args[1], 
            (GLdouble) args[2], (GLdouble) args[3], 
            (GLdouble) args[4], (GLdouble) args[5]);
}

void OpenGL_Bridge_pv::bglGenLists() {
  GLuint list = glGenLists((GLsizei) args[0]);
}

void OpenGL_Bridge_pv::bglLightfv() {
  const GLfloat* hostMem = (const GLfloat *) getHostMemory((unsigned int) args[2]);
  if(hostMem) {
    glLightfv((GLenum) args[0], (GLenum) args[1], hostMem);
  }
}

void OpenGL_Bridge_pv::bglLoadIdentity() {
  glLoadIdentity();
}

void OpenGL_Bridge_pv::bglMaterialfv() {
  const GLfloat* hostMem = (const GLfloat *) getHostMemory((unsigned int) args[2]);
  if(hostMem) {
    glMaterialfv((GLenum) args[0], (GLenum) args[1], hostMem);
  }
}

void OpenGL_Bridge_pv::bglMatrixMode() {
  glMatrixMode((GLenum) args[0]);
}

void OpenGL_Bridge_pv::bglNewList() {
  glNewList((GLuint) args[0], (GLenum) args[1]);
}

void OpenGL_Bridge_pv::bglNormal3f() {
  glNormal3f((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}
 
void OpenGL_Bridge_pv::bglOrtho() {
  glOrtho((GLdouble) args[0], (GLdouble) args[1], 
          (GLdouble) args[2], (GLdouble) args[3], 
          (GLdouble) args[4], (GLdouble) args[5]);
}

void OpenGL_Bridge_pv::bglPopMatrix() {
  glPopMatrix();
}

void OpenGL_Bridge_pv::bglPushMatrix() {
  glPushMatrix();
}

void OpenGL_Bridge_pv::bglRectf() {
  glRectf((GLfloat) args[0], (GLfloat) args[1], 
          (GLfloat) args[2], (GLfloat) args[3]);
}

void OpenGL_Bridge_pv::bglRotatef() {
  glRotatef((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2], (GLfloat) args[3]);
}

void OpenGL_Bridge_pv::bglShadeModel() {
  glShadeModel((GLenum) args[0]);
}

void OpenGL_Bridge_pv::bglTranslatef() {
  glTranslatef((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}

void OpenGL_Bridge_pv::bglVertex3f() {
  glVertex3f((GLfloat) args[0], (GLfloat) args[1], (GLfloat) args[2]);
}

void OpenGL_Bridge_pv::bglViewport() {
  glViewport((GLint) args[0], (GLint) args[1], (GLsizei) args[2], (GLsizei) args[3]);
}

