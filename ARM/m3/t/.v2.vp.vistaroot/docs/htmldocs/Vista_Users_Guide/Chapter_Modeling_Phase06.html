<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <meta name="GENERATOR" content="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.2.1385" />
    <meta name="TEMPLATEBASE" content="mgc_ww_v2.1.078" />
    <meta name="LASTUPDATED" content="Tue Nov 27 10:01:17 2012" />
    <meta name="mgc_html_doctitle" content="Vista User's Manual" />
    <title>Protocol Channels and TLM2.0 Phases</title>
<!-- Search Engine keywords -->
    <meta name="attributes" content=" doc.type.documentation.user,doc.type.documentation.ref,product.version.v3.5,product.name.vista"/>
<!-- JavaScript Files -->
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/common/context.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/js/file_list.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/js/breadcrumbs.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/js/docvars.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/common/towwhdir.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/common/wwhpagef.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/common/topics.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhelp/wwhimpl/common/scripts/popup_window.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="scripts/expand.js"></script>
    <script type="text/javascript" language="JavaScript1.2">
    <!--
      // Set reference to top level help frame
      //
      if (( window.name != "SearchTopic") && ( window.name != "PopupTopic"))
      {   var  WWHFrame = WWHGetWWHFrame(  ""); }
      else
      { var WWHFrame = eval("parent.parent"); }
      // -->
    </script>
    <script type="text/javascript" language="JavaScript1.2">
    <!--
    var  WWHFrame = eval("parent.parent");
	document.write(MGCGetInternalStyleSheet(1));
	document.write(MGCGetDocumentStyleSheet(0));
	document.write(MGCGetPGFStyleSheet(0));
    // -->
    </script>
  </head>


<body class="body" rightmargin="25" onLoad="WWHUpdate();" onUnload="WWHUnload();" onKeyDown="WWHHandleKeyDown((document.all||document.getElementById||document.layers)?event:null);" onKeyPress="WWHHandleKeyPress((document.all||document.getElementById||document.layers)?event:null);" onKeyUp="WWHHandleKeyUp((document.all||document.getElementById||document.layers)?event:null);">





 <script type="text/javascript" language="JavaScript1.2">
    <!--
      MGCInsertRTHeader(101);
    // -->
 </script>
 

<!--96,100,101-->
<!--EnDhEaDeR-->

<a name="MGCCIDPProtocol Channels and TLM2.0 Phases"></a>

<a name="wp60598"></a><h4 class="pHeading3">
  


Protocol Channels and TLM2.0 Phases
  </h4>


<!--ProtocolChannelsandTLM20Phases-->


<a name="wp60599"></a><p class="pBody">
In TLM2.0 each channel can be modeled by two phases that represent two timing points; the start of the communication in the channel and the end. If the communication is initiated by the master it sends the starting phase, while the end phase is sent by the slave (and vice-versa). The transaction initiator, which sends the first phase, is always the master.
</p>


<a name="wp61286"></a><p class="pBody">
Vista enables you to declare your own protocols. Protocol definition supports the declaration of one or multiple channels and the relationship between them. Moreover, you can specify that transactions be labeled by IDs to enable for &ldquo;out of order&rdquo; execution. 
</p>

<a name="MGCCIDPMulti-Channel Protocols "></a>

<a name="wp61287"></a><h5 class="pHeading4">
  


Multi-Channel Protocols 
</h5>



<a name="wp60604"></a><p class="pBody">
At least <span style=" font-style: italic;">Address</span> and <span style=" font-style: italic;">Data</span> channels are usually defined.
</p>


<a name="wp60606"></a><p class="pBody">
<span style=" font-style: italic;">Address</span> channels are represented as follows:
</p>


<a name="wp60607"></a>
<ul><li class="LL1BulSolid">The <span style=" font-style: italic;">Address</span> channel, for both read and write transactions, is initiated by the master.</li></ul>
<a name="wp60610"></a><p class="pBody">
<span style=" font-style: italic;">Data</span> channels are represented as follows:
</p>


<a name="wp60611"></a>
<ul><li class="LL1BulSolid">A write <span style=" font-style: italic;">Data</span> channel is typically initiated by the master, which supplies each word in a burst. </li></ul>
<a name="wp60612"></a>
<ul><li class="LL1BulSolid">A read <span style=" font-style: italic;">Data</span> channel can work in two modes: </li></ul>
<a name="wp60613"></a><ol start="1."><li class="LL2Seq"><span style=" font-weight: bold;">Initiated by master</span>: The master requests each word in a burst.</li></ol>
<a name="wp60614"></a><ol start="2."><li class="LL2Seq"><span style=" font-weight: bold;">Initiated by slave</span>: The slave sends each word. </li></ol>
<a name="wp129600"></a><p class="pL1Body">When the slave initiates the transactions, the ending of the transactions is inherently out-of-order so the protocol must include an ID label for each transaction.</p>
<a name="MGCCIDPChannels and TLM2.0 Phases"></a>

<a name="wp60616"></a><h5 class="pHeading4">
  


Channels and TLM2.0 Phases
</h5>



<a name="wp60617"></a><p class="pBody">
The four phases of the TLM2.0 base protocol can serve to model single or multi channels, both with timing accuracy. This is done in the following way:
</p>


<a name="wp60619"></a>
<ul><li class="LL1BulSolid">In a single channel, both <span style=" font-style: italic;">Read</span> and <span style=" font-style: italic;">Write</span> transactions make use of BEGIN_REQ as the first timing point and BEGIN_RESP as the second phase that complete the transaction (return TLM_COMPLETE).</li></ul>



<a name="wp61385"></a><p class="pFigureTitle">
Figure 7&#8209;2. 


Read/Write Transaction &#151;  Single Channel


</p>
<div align="center"><img src="images/RW_Trans_protocols.gif" id="wp61381" border="0" hspace="0" vspace="0"/></div><p class="pFigureTitle">





</p>



<a name="wp60621"></a>
<ul><li class="LL1BulSolid">In a multi-channel, the <span style=" font-style: italic;">Write</span> transaction is modeled by two channels: </li></ul>
<a name="wp60622"></a><ol start="1."><li class="LL2Seq">Write Address channel</li></ol>
<a name="wp61336"></a><p class="pL2Body">Using the BEGIN_REQ and END_REQ phases.</p>

<a name="wp60623"></a><ol start="2."><li class="LL2Seq">Write Data channel</li></ol>
<a name="wp61340"></a><p class="pL2Body">Using the END_REQ and BEGIN_RESP phases.</p>

<br clear="all" />
<table border="0" cellpadding="0" cellspacing="0" width="80%" align="center">
  <tr valign="baseline">
    <td width="50" valign="top" background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg">&#160;</td>
    <td background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg"><span class="cNotesBlack">Note</span></td>
  </tr>
  <tr valign="top">
    <td width="50" valign="top"><img src="wwhelp/wwhimpl/common/images/nicon_note.jpg" /></td>
    <td valign="top">
            
<a name="wp61346"></a><p class="pnoteNote">
        	The END_REQ phase is used as the second timing point of the address channel and as the first timing point of the data channel so that the end of the write transaction is in-order.(See <a href='javascript:oT("CRF","Chapter_Modeling_Phase06.html#wp61397");'>Figure&#160;7&#8209;3</a>).
        </p>

          </td>
  </tr>
  <tr height="2">
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="left" /></td>
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="right" /></td>
    </tr>
 </table>



<a name="wp61397"></a><p class="pFigureTitle">
Figure 7&#8209;3. 


Write Transaction &#151;  Multi-Channel


</p>
<div align="center"><img src="images/W_Multi.gif" id="wp61409" border="0" hspace="0" vspace="0"/></div><p class="pFigureTitle">





</p>



<a name="wp60625"></a>
<ul><li class="LL1BulSolid">The <span style=" font-style: italic;">Read</span> transaction in a multi-channel is modeled by two channels: </li></ul>
<a name="wp60626"></a><ol start="1."><li class="LL2Seq">Read Address channel</li></ol>
<a name="wp61366"></a><p class="pL2Body">BEGIN_REQ and END_REQ phases.</p>

<a name="wp60627"></a><ol start="2."><li class="LL2Seq">Read Data channel. </li></ol>
<a name="wp60628"></a><ol start="1."><li class="LL3Seq">When the read transaction is initiated by the master, it is modeled in a similar way to the write transaction.</li></ol>
<a name="wp60629"></a><p class="pL3Body">For example, the read in the PLB protocol is defined by IBM as pulling.</p>

<a name="wp60630"></a><ol start="2."><li class="LL3Seq">When the read transaction is initiated by the slave, the read data channel is represented by the BEGIN_RESP and END_RESP phases.</li></ol>
<a name="wp60631"></a><p class="pL3Body">For example, the read in the AXI protocol is defined by ARM as pushing.</p>




<a name="wp61439"></a><p class="pFigureTitle">
Figure 7&#8209;4. 


Read Transaction (Initiated by Slave) &#151;  Multi-Channel


</p>
<div align="center"><img src="images/R_Multi_Ch.gif" id="wp61441" border="0" hspace="0" vspace="0"/></div><p class="pFigureTitle">





</p>



<a name="wp60640"></a><p class="pBody">
The address channel can be shared between the <span style=" font-style: italic;">Read </span>and the <span style=" font-style: italic;">Write</span>. 
</p>


<a name="wp61190"></a><p class="pBody">
An alternate, more informative way to view how single and multi-channels are mapped to the TLM2.0 base protocol phases is via the LRM: &ldquo;nb_transport Call Sequence for each Base Protocol Transaction&rdquo; (<a href='javascript:oT("CRF","Chapter_Modeling_Phase06.html#wp61191");'>Figure&#160;7&#8209;5</a>) edited with Vista supported protocols scheme:
</p>





<a name="wp61191"></a><p class="pFigureTitle">
Figure 7&#8209;5. 


nb_transport Call Sequence for Each Base Protocol Transaction


</p>
<div align="center"><img src="images/fig_7_3_protocols.gif" id="wp61196" border="0" hspace="0" vspace="0"/></div><p class="pFigureTitle">





</p>



<a name="wp61192"></a><h6 class="pHTaskSubhead">
  Limitations
</h6>



<a name="wp60647"></a><p class="pBody">
Preemption and interleaving of data between different transactions are not supported by Vista because they are not supported naturally in TLM2.0. 
</p>


<a name="wp129662"></a><p class="pBody">
The following cannot be modeled using only TLM2.0 base protocol phases (a user defined protocol with more phases is needed):
</p>


<a name="wp60648"></a><p class="pBody">
·	A <span style=" font-style: italic;">Write</span> acknowledge channel.
</p>


<a name="wp60649"></a><p class="pBody">
·	Delay the start of the <span style=" font-style: italic;">Write </span>data channel from the end of the address channel.
</p>

<a name="MGCCIDPTiming Control"></a>

<a name="wp60651"></a><h5 class="pHeading4">
  


Timing Control
</h5>



<a name="wp60652"></a><p class="pBody">
Timing control is achieved through callbacks used at different stages of a transaction. For each port type, several types of callbacks are called (these callbacks are specified in the <span style=" font-weight: bold;">T</span> model (machine generated timing model)):
</p>


<a name="wp60653"></a>
<ul><li class="LL1BulSolid">Slave (Target) Port</li></ul>
<a name="wp60654"></a><ol start="1."><li class="LL2Seq">Transaction-Start- is called at the start of the transaction.</li></ol>
<a name="wp60655"></a><ol start="2."><li class="LL2Seq">Delay policy - is called at the start of the data phase (if there is no distinct data phase, it is called right after the <span style=" font-style: italic;">Transaction-Start</span>).</li></ol>
<a name="wp60656"></a><ol start="3."><li class="LL2Seq">Transaction-End- is called at the end of the transaction.</li></ol>
<a name="wp60657"></a>
<ul><li class="LL1BulSolid">Master (Initiator) Port</li></ul>
<a name="wp60658"></a><ol start="1."><li class="LL2Seq">Transaction-Start- is called at the start of the transaction.</li></ol>
<a name="wp60659"></a><ol start="2."><li class="LL2Seq">Transaction-End- is called at of the end of the transaction.</li></ol>
<a name="wp60663"></a><p class="pBody">
Delay policy timing is mapped to TLM phases in the following manner:
</p>





<a name="wp61161"></a><p class="pFigureTitle">
Figure 7&#8209;6. 


</p>
<div align="center"><img src="images/W_R_Pull.gif" id="wp61200" border="0" hspace="0" vspace="0"/></div><p class="pFigureTitle">







Write &amp; Read Transaction (Initiated by Master)
</p>



<br clear="all" />
<table border="0" cellpadding="0" cellspacing="0" width="80%" align="center">
  <tr valign="baseline">
    <td width="50" valign="top" background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg">&#160;</td>
    <td background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg"><span class="cNotesBlack">Note</span></td>
  </tr>
  <tr valign="top">
    <td width="50" valign="top"><img src="wwhelp/wwhimpl/common/images/nicon_note.jpg" /></td>
    <td valign="top">
            
<a name="wp60665"></a><p class="pnoteNote">
        	In &ldquo;Request accept delay&rdquo;, timing doesn't include potential arbitration time.<br />&#160;
        </p>

          </td>
  </tr>
  <tr height="2">
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="left" /></td>
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="right" /></td>
    </tr>
 </table>
<a name="wp101299"></a><p class="pBody">
Both <span style=" font-style: italic;">Latency</span> and <span style=" font-style: italic;">WaitState</span> parameters of the <span style=" font-style: italic;">Delay</span> policy can be specified statically (through the GUI) or dynamically in the Vista <span style=" font-weight: bold; font-style: italic;">T</span> (Timing) model.
</p>





<a name="wp61165"></a><p class="pFigureTitle">
Figure 7&#8209;7. 


Read Transaction (Initiated by Slave)


</p>
<div align="center"><img src="images/R_Pushing.gif" id="wp61214" border="0" hspace="0" vspace="0"/></div><p class="pFigureTitle">





</p>


<a name="MGCCIDPTransactions Rescheduling"></a>

<a name="wp60671"></a><h5 class="pHeading4">
  


Transactions Rescheduling
</h5>



<a name="wp60672"></a><p class="pBody">
The callbacks (Transaction-Start, Transaction-End) enable rescheduling the start of pending transactions forward and backward in time. Transactions can be moved backwards from the far future of the simulation time to a nearer future. Thus arbitration of concurrent transactions can be implemented. Preemption is also supported.
</p>


<a name="wp60674"></a><p class="pBody">
For example, assume a memory controller IP that has a queue of pending transactions: 
</p>


<a name="wp60676"></a>
<ul><li class="LL1BulSolid">Data stage delay: The starting time of a transaction's pending data stage can be moved forward in time, if a data stage of a transaction with higher priority arrives.</li></ul>
<a name="wp60678"></a>
<ul><li class="LL1BulSolid">A <span style=" font-style: italic;">Read</span> transaction is requested from a memory controller, which is connected to a slow memory. The controller issues a transaction to the memory with the appropriate delay. After two clocks, a <span style=" font-style: italic;">Read</span> transaction with a higher priority arrives. The previous memory access is aborted and is overridden by the new memory access. The new time for the first transaction's data phase is recalculated and the transaction's data phase is rescheduled.</li></ul>
<a name="wp60680"></a>
<ul><li class="LL1BulSolid">Delay data stage to an unknown-time: The starting time of a transaction's data can be scheduled to infinity, when its starting time is not known upfront. It can be moved to a known time in a different transaction's end-callback.</li></ul>
<a name="wp60682"></a><p class="pBody">
Assume a <span style=" font-style: italic;">Read</span> transaction is entered into transaction queue. The <span style=" font-style: italic;">Read</span> request time is set to infinity, the model does not try to calculate this time upfront, because transaction(s) with a higher priority may arrive meanwhile and will force recalculations. When the transaction handle is popped from the queue, its data phase timing is recalculated and the transaction's data phase is rescheduled.
</p>


<a name="wp60684"></a><p class="pBody">
The same callbacks allow arbitration of transactions that arrive on multiple slave ports, for example, multi-port memory. The starting time of a transaction's data can be scheduled to infinity in the delay policy callback, and its handle can be put in a data structure that belongs to the model and rescheduled when the time comes.
</p>

<a name="MGCCIDPGeneral Protocol Parameters"></a>

<a name="wp60687"></a><h5 class="pHeading4">
  


General Protocol Parameters
</h5>



<a name="wp60688"></a><p class="pBody">
These parameters are automatically generated for each port.
</p>

<a name="MGCCIDPPipeline Length"></a>

<a name="wp60690"></a><h6 class="pHeading5">
  


Pipeline Length
</h6>



<a name="wp60692"></a><h6 class="pzHeading">
  Syntax
  </h6>


<a name="wp61648"></a><p class="pzUsage">
<span class="cReqRpl">port_name</span>_pipeline_length 
</p>


<a name="wp60693"></a><h6 class="pzHeading">
  Properties
  </h6>


<a name="wp60694"></a><ul class="ulSmSpace"><li class="LLzptArg">The parameter is defined for a slave port.</li></ul>

<a name="wp60695"></a><ul class="ulSmSpace"><li class="LLzptArg">The parameter is common to all protocols.</li></ul>

<a name="wp60697"></a><p class="pzBody">
The pipeline length parameter models the maximum number of callbacks that can be pipelined. 
</p>


<a name="wp60698"></a><p class="pzBody">
This parameter value corresponds to the amount of concurrent hardware that implements the HDL model.
</p>


<a name="wp60699"></a><p class="pzBody">
A warning is issued when the number of concurrent callbacks exceeds the pipeline length parameter value.
</p>


<a name="wp60701"></a><p class="pzBody">
Assume the following &ldquo;fir filter&rdquo; component example. It gets triggered, reads input writes output and only then is able to accept the next trigger. In this case pipeline length should be one. Let us look at the following code:
</p>


<a name="wp60703"></a><pre class="pCode">         int input [ taps ] ;</pre>


<a name="wp60704"></a><pre class="pCode">         int output [ taps ] ;</pre>


<a name="wp60705"></a><pre class="pCode">         running = 1 ;  // running is a memory mapped register</pre>


<a name="wp60706"></a><pre class="pCode">         master_read ( in_buffer_addr, input, buf_size ) ; </pre>


<a name="wp60707"></a><pre class="pCode">         for ( int j = 0 ; j &lt; buf_size ; j ++ ) </pre>


<a name="wp60708"></a><pre class="pCode">           comput_fir ( input [ j ] , output [ j ] ) ;</pre>


<a name="wp60709"></a><pre class="pCode">         master_write ( out_buffer_addr, output, buf_size ) ;</pre>


<a name="wp60710"></a><pre class="pCode">         running = 0;</pre>


<a name="wp60711"></a><pre class="pCode">     </pre>


<a name="wp60712"></a><p class="pzBody">
It is sufficient for software running on the CPU to poll the `running' register for idle before triggering the component. However if the software is not written correctly, the user gets a warning when the component is triggered while the filter is running.
</p>


<a name="wp60714"></a><p class="pzBody">
The following code will ensure that the component will not start another computation before returning to idle mode:
</p>


<a name="wp60716"></a><pre class="pCode">         int input [ taps ] ;</pre>


<a name="wp60717"></a><pre class="pCode">         int output [ taps ] ;</pre>


<a name="wp61747"></a><pre class="pCode">         if (running == 0) {</pre>


<a name="wp61748"></a><pre class="pCode">            running = 1 ;  // running is a memory mapped register</pre>


<a name="wp60720"></a><pre class="pCode">            master_read ( in_buffer_addr, input, buf_size ) ; </pre>


<a name="wp60721"></a><pre class="pCode">            for ( int j = 0 ; j &lt; buf_size ; j ++ ) </pre>


<a name="wp60722"></a><pre class="pCode">              comput_fir ( input [ j ] , output [ j ] ) ;</pre>


<a name="wp60723"></a><pre class="pCode">            master_write ( out_buffer_addr, output, buf_size ) ;</pre>


<a name="wp60724"></a><pre class="pCode">            running = 0;</pre>


<a name="wp60725"></a><pre class="pCode">        }</pre>


<a name="wp61039"></a><pre class="pCode">     </pre>


<a name="wp60727"></a><p class="pzBody">
This is a description of a valid hardware component that ignores input data when it is not able to accept it (an invalid trigger). In order not to get a warning, the pipeline length should be set to 2. One pipeline which serves the first FIR request and a second pipeline for rejecting un-serviceable requests.
</p>


<a name="wp60729"></a><p class="pzBody">
Vista also provides an API to check the pipeline count, allowing it to check the current pipeline value before reaching the maximum.
</p>


<a name="wp60730"></a><pre class="pCode">     int get_pipeline_count (int port_index) ;</pre>

<a name="MGCCIDPThe Number of the Outstanding Transactions "></a>

<a name="wp60732"></a><h6 class="pHeading5">
  


The Number of the Outstanding Transactions 
</h6>



<a name="wp60734"></a><h6 class="pzHeading">
  Syntax
  </h6>


<a name="wp61680"></a><p class="pzUsage">
<span class="cReqRpl">port_name</span>_outstanding
</p>


<a name="wp60735"></a><h6 class="pzHeading">
  Properties
  </h6>


<a name="wp60736"></a>
<ul><li class="LL1BulSolid">The parameter controls how many transactions may be issued or received concurrently. In case the limit has been reached, the next transaction waits till a transaction finishes.</li></ul>
<a name="wp60737"></a>
<ul><li class="LL1BulSolid">No warning is issued when the limit has been reached.</li></ul>
<a name="wp60738"></a><p class="pBody">
The parameter is defined for both master and slave ports (except for those belonging to a bus, refer to <a href='javascript:oT("CRF","Chapter_Modeling_Phase06.html#wp60760");'>The Bus Model</a> description).
</p>


<a name="wp60740"></a><p class="pBody">
A protocol that has separate address and data channels can enable multiple outstanding transactions. Support of out-of-order transactions amplifies this opportunity. Memory space has to be allocated in order to support multiple outstanding transactions; hence the number of the outstanding transactions is limited.
</p>


<a name="wp60742"></a><p class="pBody">
The following examples illustrate this point:
</p>


<a name="wp60744"></a>
<ol start="1."><li class="LL1Seq">A DDR controller defined with outstanding transactions has to allocate for each incoming <span style=" font-style: italic;">Read</span> transaction a memory buffer in order to save the data until it can be fully transferred back to the master. For <span style=" font-style: italic;">Write</span> transactions, the values need to be saved until they can be written into the DDR memory.</li></ol>
<a name="wp60746"></a>
<ol start="2."><li class="LL1Seq">A DDR controller supporting out-of-order transactions must save each transaction's ID in order to send a return value or acknowledgement.</li></ol><a name="MGCCIDPData Queue Size"></a>

<a name="wp60748"></a><h6 class="pHeading5">
  


Data Queue Size
</h6>



<a name="wp60750"></a><h6 class="pzHeading">
  Syntax
  </h6>


<a name="wp61694"></a><p class="pzUsage">
<span class="cReqRpl">port_name</span>_read_data_queue_size
</p>


<a name="wp60751"></a><p class="pzUsage">
<span class="cReqRpl">port_name</span>_write_data_queue_size
</p>


<a name="wp60753"></a><h6 class="pzHeading">
  Properties
  </h6>


<a name="wp60754"></a>
<ul><li class="LL1BulSolid">The <span style=" font-style: italic;">Queue Size</span> parameter controls the aggregate data size in bytes of all the transactions which may be handled concurrently.</li></ul>
<a name="wp60755"></a>
<ul><li class="LL1BulSolid">The parameter is equivalent to the hardware buffer implementation.</li></ul>
<a name="wp60756"></a>
<ul><li class="LL1BulSolid">When a transaction is issued which exceeds the queue size limit, it has to wait until enough space is evacuated in the queue when previous transactions finish.</li></ul>
<a name="wp60757"></a>
<ul><li class="LL1BulSolid">When a transaction has to wait due to the queue size limit, no warning message is generated.</li></ul>
<a name="wp60758"></a>
<ul><li class="LL1BulSolid">The parameter is defined for both master and slave ports (except for those belonging to a bus, refer to <a href='javascript:oT("CRF","Chapter_Modeling_Phase06.html#wp60760");'>The Bus Model</a> description).</li></ul><a name="MGCCIDPThe Bus Model"></a>

<a name="wp60760"></a><h5 class="pHeading4">
  


The Bus Model
</h5>



<a name="wp60761"></a><p class="pBody">
The Bus model supports any number of master and slave ports and can be configured to single and multi-layering schemes. The Bus interconnect matrix as well as other attributes are set through its parameters. Detailed description of TLM based bus architecture and its parameters is provided separately in this manual. Refer to the <a href='javascript:oT("CRF","Chapter_Customizing_Gen_Models_new03.html");'>Bus</a> model in the <a href='javascript:oT("CRF","Chapter_Customizing_Gen_Models_new01.html");'>The Generic Models and Models Catalogue Libraries</a> chapter.
</p>

<a name="MGCCIDPBus Arbitration"></a>

<a name="wp60763"></a><h5 class="pHeading4">
  


Bus Arbitration
</h5>



<a name="wp60764"></a><p class="pBody">
Forward arbitration is a part of the address channel. It is done by the bus at each clock cycle, when the address channel is free and there are multiple waiting transactions. It is done on a priority base, with FIFO order between transactions of the same priority. 
</p>


<a name="wp60766"></a><p class="pBody">
For protocols, with pushing-read data channel, there will be a backward arbitration point for each master layer as a part of the read data channel.
</p>


<a name="wp60768"></a><p class="pBody">
Arbitration deals with whole transactions due to the TLM level and not with words as done in lower level implementation. In other words, the data transfer time is calculated from the number of data words, and not by actual handshakes.
</p>


<a name="wp60769"></a><p class="pBody">
The arbitration scheme can be changed by customizing the provided arbitration class (class: Arbiter in Arbiter.h)
</p>

<a name="MGCCIDPBus Policies"></a>

<a name="wp60771"></a><h5 class="pHeading4">
  


Bus Policies
</h5>



<a name="wp60772"></a><p class="pBody">
You can define pipeline policies between the bus ports. Thus different latencies can be defined between slave transactions and the start of the corresponding master transactions.
</p>


<a name="wp60774"></a><p class="pBody">
The bus allocates memory buffers in order to support multiple outstanding transactions as the following examples show:
</p>


<a name="wp60776"></a>
<ol start="1."><li class="LL1Seq">The bus must save a transaction's source and destination, so that slave responses can be routed to the correct master.</li></ol>
<a name="wp60777"></a>
<ol start="2."><li class="LL1Seq">A bus which supports out-of-order transactions will need to buffer data for masters which do not directly support out-of-order transactions.</li></ol><a name="MGCCIDPBus Port Parameters"></a>

<a name="wp60779"></a><h5 class="pHeading4">
  


Bus Port Parameters
</h5>



<a name="wp60780"></a><p class="pBody">
The <span style=" font-style: italic;">outstanding-transaction</span> and <span style=" font-style: italic;">queue-size</span> parameters are not defined within the bus; they are taken from the ports that are bound to the bus ports.
</p>


<a name="wp60782"></a><p class="pBody">
If you want to use a different method to support multiple outstanding transactions, it should implement your own callbacks. (For example it can have a buffer, which is shared by transactions for all the slaves connected to it, whose size is lower than the sum of all the slaves' buffers).
</p>


<a name="wp60784"></a><p class="pBody">
Some protocols have extensions that affect the bus routing, arbitration and timing. The way to model these extensions is to add extensions to the TLM2.0 generic payload. These extensions are set by the master and used in the route, arbitration and timing callback user defined functions.
</p>




<script type="text/javascript" language="JavaScript1.2">
<!--
   PageTitle = "Protocol Channels and TLM2.0 Phases";
   PDFLinkTitle = "Protocol.Channels.and.TLM2.0.Phases"
   ThisTopic = "BusPortParameters";
   CurrentFile = "Chapter_Modeling_Phase06.html";
   MGCSetDocumentVariables();
   MGCUpdateNavPane();
      MGCInsertRTFooter();
 // -->
 </script>



  </body>
</html>
