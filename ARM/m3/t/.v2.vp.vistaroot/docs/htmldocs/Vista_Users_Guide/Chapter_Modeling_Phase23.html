<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <meta name="GENERATOR" content="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.2.1385" />
    <meta name="TEMPLATEBASE" content="mgc_ww_v2.1.078" />
    <meta name="LASTUPDATED" content="Tue Nov 27 10:01:17 2012" />
    <meta name="mgc_html_doctitle" content="Vista User's Manual" />
    <title>Functions for Master/Slave Ports and Registers</title>
<!-- Search Engine keywords -->
    <meta name="attributes" content=" doc.type.documentation.user,doc.type.documentation.ref,product.version.v3.5,product.name.vista"/>
<!-- JavaScript Files -->
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/common/context.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/js/file_list.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/js/breadcrumbs.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/js/docvars.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/common/towwhdir.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/common/wwhpagef.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhdata/common/topics.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="wwhelp/wwhimpl/common/scripts/popup_window.js"></script>
    <script type="text/javascript" language="JavaScript1.2" src="scripts/expand.js"></script>
    <script type="text/javascript" language="JavaScript1.2">
    <!--
      // Set reference to top level help frame
      //
      if (( window.name != "SearchTopic") && ( window.name != "PopupTopic"))
      {   var  WWHFrame = WWHGetWWHFrame(  ""); }
      else
      { var WWHFrame = eval("parent.parent"); }
      // -->
    </script>
    <script type="text/javascript" language="JavaScript1.2">
    <!--
    var  WWHFrame = eval("parent.parent");
	document.write(MGCGetInternalStyleSheet(1));
	document.write(MGCGetDocumentStyleSheet(0));
	document.write(MGCGetPGFStyleSheet(0));
    // -->
    </script>
  </head>


<body class="body" rightmargin="25" onLoad="WWHUpdate();" onUnload="WWHUnload();" onKeyDown="WWHHandleKeyDown((document.all||document.getElementById||document.layers)?event:null);" onKeyPress="WWHHandleKeyPress((document.all||document.getElementById||document.layers)?event:null);" onKeyUp="WWHHandleKeyUp((document.all||document.getElementById||document.layers)?event:null);">





 <script type="text/javascript" language="JavaScript1.2">
    <!--
      MGCInsertRTHeader(118);
    // -->
 </script>
 

<!--96,117,118-->
<!--EnDhEaDeR-->

<a name="MGCCIDPFunctions for Master/Slave Ports and Registers"></a>

<a name="wp26029"></a><h4 class="pHeading3">
  


Functions for Master/Slave Ports and Registers
  </h4>


<!--FunctionsforMasterSlavePortsandRegisters-->


<a name="wp25586"></a><p class="pBody">
The model builder in Vista provides a convenience layer on top of TLM 2.0 to simplify the modeling task. 
</p>


<a name="wp25592"></a><p class="pBody">
The following section outlines master, slave, and register functions to be used for PV Modeling. 
</p>


<a name="wp25606"></a><p class="pBody">
These functions should be used for ports of any bus Protocol.
</p>

<a name="MGCCIDPMaster Ports"></a>

<a name="wp25666"></a><h5 class="pHeading4">
  


Master Ports
</h5>



<a name="wp25671"></a><p class="pBody">
The naming scheme of the functions has a predefined structure, as shown below:
</p>


<a name="wp25668"></a><pre class="pCodeIndent">
           bool <span class="cReqRpl">port_name</span>_read(unsigned int address, <span class="cReqRpl">int_data_type</span>&amp; data);</pre>

<a name="wp35279"></a><pre class="pCodeIndent">
           </pre>

<a name="wp43959"></a><pre class="pCodeIndent">
           // Initiate Read Transaction on the Master port_name</pre>

<a name="wp35280"></a><pre class="pCodeIndent">
           // reads single data at address &quot;address&quot; using <span class="cReqRpl">port_name</span> port</pre>

<a name="wp35281"></a><pre class="pCodeIndent">
           // returns true on success, false on failure</pre>

<a name="wp25621"></a><pre class="pCodeIndent">
           </pre>

<a name="wp43966"></a><pre class="pCodeIndent">
           </pre>

<a name="wp44043"></a><pre class="pCodeIndent">
           bool <span class="cReqRpl">port_name</span>_read(unsigned int address, <span class="cReqRpl">int_data_type</span>* data, unsigned wordCount, unsigned streaming_width = 0);</pre>

<a name="wp44044"></a><pre class="pCodeIndent">
           </pre>

<a name="wp43965"></a><pre class="pCodeIndent">
           // Initiate Burst Read Transaction on the Master port_name </pre>

<a name="wp25624"></a><pre class="pCodeIndent">
           // reads wordCount blocks from address &quot;address&quot; using <span class="cReqRpl">port_name</span></pre>

<a name="wp25625"></a><pre class="pCodeIndent">
           // data should be allocated with wordCount</pre>

<a name="wp25626"></a><pre class="pCodeIndent">
           // returns true on success, false on failure</pre>

<a name="wp42961"></a><pre class="pCodeIndent">
           </pre>

<a name="wp43967"></a><pre class="pCodeIndent">
           </pre>

<a name="wp34235"></a><pre class="pCodeIndent">
           bool <span class="cReqRpl">port_name</span>_write(unsigned int address, <span class="cReqRpl">int_data_type</span> data);</pre>

<a name="wp25629"></a><pre class="pCodeIndent">
           </pre>

<a name="wp43958"></a><pre class="pCodeIndent">
           // Initiate Write Transaction on the Master port_name </pre>

<a name="wp25630"></a><pre class="pCodeIndent">
           // write single data to address &quot;address&quot;, using <span class="cReqRpl">port_name</span></pre>

<a name="wp25631"></a><pre class="pCodeIndent">
           // returns true on success, false on failure</pre>

<a name="wp25632"></a><pre class="pCodeIndent">
           </pre>

<a name="wp44041"></a><pre class="pCodeIndent">
           </pre>

<a name="wp34240"></a><pre class="pCodeIndent">
           bool <span class="cReqRpl">port_name</span>_write(unsigned int address, <span class="cReqRpl">int_data_type</span>* data, unsigned wordCount, unsigned streaming_width = 0); </pre>

<a name="wp25634"></a><pre class="pCodeIndent">
           <br />           // Initiate Burst Write Transaction on the Master port_name </pre>

<a name="wp25635"></a><pre class="pCodeIndent">
           // write wordCount blocks to address &quot;address&quot; using <span class="cReqRpl">port_name</span></pre>

<a name="wp25636"></a><pre class="pCodeIndent">
           // returns true on success, false on failure</pre>

<a name="wp35295"></a><pre class="pCodeIndent">
           </pre>

<a name="wp44051"></a><pre class="pCodeIndent">
           </pre>

<a name="wp35296"></a><p class="pBody">
There is a function for each of the following int data types: <span style=" font-weight: bold;">char, short, int, long long, unsigned char</span>, <span style=" font-weight: bold;">unsigned short</span>, <span style=" font-weight: bold;">unsigned int </span>and <span style=" font-weight: bold;">unsigned long long</span>.
</p>


<a name="wp34998"></a><p class="pBody">
The TLM 2.0 <span style=" font-weight: bold;">b_transport</span> function is called from the convenience layer.
</p>


<a name="wp26002"></a><p class="pBody">
All these functions are declared in <span class="cReqRpl">model_name</span><span style=" font-weight: regular; font-style: italic;">_model.h</span>.
</p>


<a name="wp34274"></a><p class="pBody">
There are also similar functions that use the debug transport (<span style=" font-weight: bold;">transport_dbg</span>) interface. This is a non-intrusive interface, providing a means to read and write to storage in a target, over the same forward path from initiator to target as is used by the transport interface, but without any of the delays, waits, event notifications or side effects associated with a regular transaction. An implementation of this interface can perform the same address translation as for regular transactions. For more information, see the TLM2.0 documentation.
</p>


<a name="wp34278"></a><p class="pBody">
The following functions are provided for this interface:
</p>


<a name="wp34280"></a><pre class="pCodeIndent">
           unsigned <span class="cReqRpl">port_name</span>_read_dbg(unsigned int address, <br />           <span class="cReqRpl">int_data_type</span>* data, unsigned wordCount);<br />           </pre>

<a name="wp34282"></a><pre class="pCodeIndent">
           unsigned <span class="cReqRpl">port_name</span>_write_dbg(unsigned int address, <br />           <span class="cReqRpl">int_data_type</span>* data, unsigned wordCount);</pre>

<a name="wp34284"></a><pre class="pCodeIndent">
           </pre>

<a name="wp44056"></a><pre class="pCodeIndent">
           unsigned <span class="cReqRpl">port_name</span>_read_dbg(unsigned int address, <br />           <span class="cReqRpl">int_data_type</span>&amp; data) ;</pre>

<a name="wp44057"></a><pre class="pCodeIndent">
           </pre>

<a name="wp34285"></a><pre class="pCodeIndent">
           unsigned <span class="cReqRpl">port_name</span>_write_dbg(unsigned int address, <br />           <span class="cReqRpl">int_data_type</span> data);<br />           </pre>

<a name="wp34399"></a><p class="pBody">
There is a function for each of the following int data types: <span style=" font-weight: bold;">char, short, int, long long, unsigned char</span>, <span style=" font-weight: bold;">unsigned short</span>, <span style=" font-weight: bold;">unsigned int</span> and <span style=" font-weight: bold;">unsigned long long</span>.
</p>


<a name="wp35344"></a><p class="pBody">
The parameters address, data, wordCount are same as in the <span style=" font-weight: bold;">b_transport</span> interface. The return value, as that of the <span style=" font-weight: bold;">transport_dbg</span> interface, is a count of the number of bytes actually read or written, which may be less than <span style=" font-weight: bold; font-style: italic;">num_bytes</span>. A value of 0 is returned if the target is not able to perform the operation.
</p>


<a name="wp34272"></a><p class="pBody">
When the<span style=" font-style: italic;"> port width </span>is specified in the Port section GUI, the function's signature includes the appropriate &ldquo;port_data_type&rdquo; type according to its computed standard value (see the Width field in the table <a href='javascript:oT("CRF","Chapter_Modeling_Phase15.html#wp28052");'>&quot;Vista Modeling - Ports Tab Options&quot;</a>) and the following table:
</p>
<div id="TableDivQz"></div>
<div align="center">


<a name="wp25811"></a><p class="pTableTitle">
Table 7&#8209;8. 


Port Data Types
</p>



<table border="1" cellpadding="5" cellspacing="0" id="wp25811table25809">
  <tr align="left" valign="top">
    <td>


<a name="wp25815"></a><p class="pTableHeading">
Port Width
</p>
</td>

    <td>


<a name="wp25817"></a><p class="pTableHeading">
Port Data Type
</p>


</td>


</tr>

  <tr align="left" valign="top">
    <td>


<a name="wp25819"></a><p class="pTableCell">
<span class="cP12"><span style=" font-weight: bold; font-angle: normal; vertical-align: baseline; color:#000000;">8</span></span>

</p>

</td>

    <td>


<a name="wp25821"></a><p class="pTableCell">
unsigned char

</p>

</td>


</tr>

  <tr align="left" valign="top">
    <td>


<a name="wp25823"></a><p class="pTableCell">
<span class="cP12"><span style=" font-weight: bold; font-angle: normal; vertical-align: baseline; color:#000000;">16</span></span>

</p>

</td>

    <td>


<a name="wp25825"></a><p class="pTableCell">
unsigned short

</p>

</td>


</tr>

  <tr align="left" valign="top">
    <td>


<a name="wp25830"></a><p class="pTableCell">
<span class="cP12"><span style=" font-weight: bold; font-angle: normal; vertical-align: baseline; color:#000000;">32</span></span>

</p>

</td>

    <td>


<a name="wp25832"></a><p class="pTableCell">
unsigned int

</p>

</td>


</tr>

  <tr align="left" valign="top">
    <td>


<a name="wp25834"></a><p class="pTableCell">
<span class="cP12"><span style=" font-weight: bold; font-angle: normal; vertical-align: baseline; color:#000000;">64</span></span>

</p>

</td>

    <td>


<a name="wp25836"></a><p class="pTableCell">
unsigned long long

</p>

</td>


</tr>


</table>

</div>
<div id='EndTable'> </div>
<p class="pBody">
<br clear='left' class='Blank4Table' />


</p>

<a name="MGCCIDPSlave Ports"></a>

<a name="wp25685"></a><h5 class="pHeading4">
  


Slave Ports
</h5>



<a name="wp25687"></a><p class="pBody">
For each slave port there are two callbacks provided, generated in <span class="cReqRpl">model_name</span><span style=" font-weight: regular; font-style: italic;">_pv.h</span>. These functions are called whenever a transaction is received on the slave (target) port <span class="cReqRpl">port_name</span>.
</p>


<a name="wp25689"></a><p class="pBody">
The created functions are templates in which the user should supply the code to be executed upon receiving a transaction. 
</p>


<a name="wp35178"></a><pre class="pCodeIndent">
           virtual bool <span class="cReqRpl">port_name</span>_callback_read(unsigned int address,</pre>

<a name="wp35180"></a><pre class="pCodeIndent">
           unsigned char* data, unsigned size);</pre>

<a name="wp35182"></a><pre class="pCodeIndent">
           // A read request of wordCount blocks from address &quot;address&quot;</pre>

<a name="wp35184"></a><pre class="pCodeIndent">
           // The data should be put into &quot;data&quot; parameter.</pre>

<a name="wp35186"></a><pre class="pCodeIndent">
           // Returns true on success, false on failure.</pre>

<a name="wp35188"></a><pre class="pCodeIndent">
           </pre>

<a name="wp35190"></a><pre class="pCodeIndent">
           virtual bool <span class="cReqRpl">port_name</span>_callback_write(unsigned int address,</pre>

<a name="wp35192"></a><pre class="pCodeIndent">
           unsigned char* data, unsigned size);</pre>

<a name="wp35194"></a><pre class="pCodeIndent">
           // A write request for size bytes to address &quot;address&quot;</pre>

<a name="wp35196"></a><pre class="pCodeIndent">
           // &quot;data&quot; contains &quot;size&quot; bytes with the data that is to be</pre>

<a name="wp35198"></a><pre class="pCodeIndent">
           // written.</pre>

<a name="wp35200"></a><pre class="pCodeIndent">
           // Returns true on success, false on failure</pre>

<a name="wp26973"></a><pre class="pCodeIndent">
           </pre>

<a name="wp34404"></a><p class="pBody">
The <span style=" font-weight: bold;">transport_dbg</span> functions are:
</p>


<a name="wp35240"></a><pre class="pCodeIndent">
           virtual unsigned <span class="cReqRpl">port_name</span>_callback_read_dbg(unsigned int address, unsigned char* data, unsigned size);</pre>

<a name="wp35243"></a><pre class="pCodeIndent">
           </pre>

<a name="wp35254"></a><pre class="pCodeIndent">
           virtual unsigned <span class="cReqRpl">port_name</span>_callback_write_dbg(unsigned int address, unsigned char* data, unsigned size);</pre>

<a name="wp35247"></a><pre class="pCodeIndent">
           </pre>

<a name="wp34409"></a><p class="pBody">
The return value should be a count of the number of bytes actually read or written, which may be less than <span style=" font-style: italic;">num_bytes</span>. A value of 0 is used if the target is not able to perform the operation.
</p>


<a name="wp34411"></a><p class="pBody">
The <span style=" font-weight: bold;">transport_dbg</span> interface has the default implementation for all the generic models.
</p>


<br clear="all" />
<table border="0" cellpadding="0" cellspacing="0" width="80%" align="center">
  <tr valign="baseline">
    <td width="50" valign="top" background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg">&#160;</td>
    <td background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg"><span class="cNotesBlack">Note</span></td>
  </tr>
  <tr valign="top">
    <td width="50" valign="top"><img src="wwhelp/wwhimpl/common/images/nicon_note.jpg" /></td>
    <td valign="top">
            
<a name="wp34412"></a><p class="pnoteNote">
        	There is a special implementation for it in the <span style=" font-weight: bold;">mb_memory</span> class. During simulation, calling to the <span style=" font-weight: bold;">mb_memory</span> classes through the <span style=" font-weight: bold;">transport_dbg</span> interface will have the same effect as <span style=" font-weight: bold;">b_transport</span>, except that the register callbacks will not be called.
        </p>

          </td>
  </tr>
  <tr height="2">
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="left" /></td>
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="right" /></td>
    </tr>
 </table>
<a name="wp34503"></a><p class="pBody">
When the <span style=" font-style: italic;">port width </span>is specified in the Port section GUI, the function's signature includes the appropriate &ldquo;port_data_type&rdquo; type according to its computed standard value (see the Width field in <a href='javascript:oT("CRF","Chapter_Modeling_Phase15.html#wp28052");'>Table&#160;7&#8209;1</a>, and <a href='javascript:oT("CRF","Chapter_Modeling_Phase23.html#wp25811");'>Table&#160;7&#8209;8</a>).
</p>

<a name="MGCCIDPDirect Memory Interface (DMI)"></a>

<a name="wp34414"></a><h5 class="pHeading4">
  


Direct Memory Interface (DMI)
</h5>



<a name="wp34419"></a><p class="pBody">
The Direct Memory Interface provides a means by which an initiator can get direct access to an area of memory owned by a target, so that memory can be accessed using a direct pointer rather than through the transport interface. This can increase the simulation speed for memory access between initiator and target, because the normal path of multiple <span style=" font-weight: bold;">b_transport</span> or <span style=" font-weight: bold;">nb_transport</span> calls from initiator through interconnect components to target is bypassed. 
</p>


<a name="wp34535"></a><p class="pBody">
For each slave port, the following callback is created:
</p>


<a name="wp34536"></a><pre class="pCodeIndent">
           bool <span class="cReqRpl">port_name</span>_get_direct_memory_ptr(unsigned int address, tlm::tlm_dmi&amp; dmiData);<br />           </pre>

<a name="wp34531"></a><p class="pBody">
For more information, see the TLM2.0 documentation.
</p>


<br clear="all" />
<table border="0" cellpadding="0" cellspacing="0" width="80%" align="center">
  <tr valign="baseline">
    <td width="50" valign="top" background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg">&#160;</td>
    <td background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg"><span class="cNotesBlack">Note</span></td>
  </tr>
  <tr valign="top">
    <td width="50" valign="top"><img src="wwhelp/wwhimpl/common/images/nicon_note.jpg" /></td>
    <td valign="top">
            
<a name="wp34421"></a><p class="pnoteNote">
        	DMI is currently supported only in the <span style=" font-weight: bold;">mb_mem_range</span> objects. For all the other memory objects (e.g., Registers or FIFOs) a value of &ldquo;false&rdquo; is returned.
        </p>

          </td>
  </tr>
  <tr height="2">
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="left" /></td>
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="right" /></td>
    </tr>
 </table><a name="MGCCIDPRegister Callbacks"></a>

<a name="wp33087"></a><h5 class="pHeading4">
  


Register Callbacks
</h5>



<a name="wp25716"></a><p class="pBody">
For each register defined as &ldquo;Trigger&rdquo; a callback function is provided and being called upon writing/reading to/from this register:
</p>


<a name="wp25718"></a><pre class="pCodeIndent">
           <span class="cReqRpl">register_data_type</span> cb_read_<span class="cReqRpl">Register_Name</span>()</pre>

<a name="wp25719"></a><pre class="pCodeIndent">
           void cb_write_<span class="cReqRpl">Register_Name</span>(<span class="cReqRpl">register_data_type</span> newValue)<br />           </pre>

<a name="wp25720"></a><p class="pBody">
When <span style=" font-weight: bold;">cb_write</span> is called, the register has already been assigned with the new value. If, for some reason, the old value of the register is needed in the consequent write callback, it should be saved in a field of the model. The value returned by <span style=" font-weight: bold;">cb_read</span> is assigned to the register when the callback returns and can be subsequently accessed.
</p>


<br clear="all" />
<table border="0" cellpadding="0" cellspacing="0" width="80%" align="center">
  <tr valign="baseline">
    <td width="50" valign="top" background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg">&#160;</td>
    <td background="wwhelp/wwhimpl/common/images/nbrule_upper.jpg"><span class="cNotesBlack">Note</span></td>
  </tr>
  <tr valign="top">
    <td width="50" valign="top"><img src="wwhelp/wwhimpl/common/images/nicon_note.jpg" /></td>
    <td valign="top">
            
<a name="wp25722"></a><p class="pnoteNote">
        	Register callbacks are called before the slave port callbacks are called.
        </p>

          </td>
  </tr>
  <tr height="2">
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="left" /></td>
    <td height="2" background="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg"><img src="wwhelp/wwhimpl/common/images/nbrule_bottom.jpg" align="right" /></td>
    </tr>
 </table>
<a name="wp25726"></a><p class="pBody">
When specifying Register width in the Register section GUI, the functions signature will include the appropriate &ldquo;register_data_type&rdquo; type according to its computed standard value (see the Width field in <a href='javascript:oT("CRF","Chapter_Modeling_Phase15.html#wp28052");'>Table&#160;7&#8209;1</a>, and <a href='javascript:oT("CRF","Chapter_Modeling_Phase23.html#wp25811");'>Table&#160;7&#8209;8</a>).
</p>

<a name="MGCCIDPRegister Reset"></a>

<a name="wp96620"></a><h5 class="pHeading4">
  


Register Reset
</h5>



<a name="wp96621"></a><p class="pBody">
The pv base class has a virtual function: 
</p>


<a name="wp96622"></a><pre class="pCode">     void reset_model()</pre>


<a name="wp120223"></a><pre class="pCode">     </pre>


<a name="wp96623"></a><p class="pBody">
The function assigns a reset value to all registers and signals when called.
</p>


<a name="wp133998"></a><p class="pBody">
Because the function is virtual, you can override the function by using the <span class="cReqRpl">model_name</span><span style=" font-weight: regular; font-style: italic;">_pv.cpp</span> file to initialize some user-defined members, mb_variables, and so forth, then calling: <span class="cReqRpl">model_name</span>_base_pv::reset_model() to initialize all registers and signals.
</p>

<a name="MGCCIDPSignal Protocol Modeling"></a>

<a name="wp25738"></a><h5 class="pHeading4">
  


Signal Protocol Modeling
</h5>



<a name="wp59985"></a><p class="pBody">
Ports of Signal Protocol are used like SystemC signals, e.g. they are to model interrupts.
</p>


<a name="wp59986"></a><p class="pBody">
For a master port of Signal Protocol a SystemC sc_out port is generated. One can both read from and write to such port. For example:
</p>


<a name="wp59988"></a><pre class="pCode">     // port_a is declared as sc_out<span class="cReqRpl">bool</span> port_a;</pre>


<a name="wp59989"></a><pre class="pCode">     port_a.write(true);</pre>


<a name="wp59990"></a><pre class="pCode">     bool variable_a= port_a.read(); </pre>


<a name="wp60035"></a><pre class="pCode">     </pre>


<a name="wp59992"></a><p class="pBody">
The write function call generates a transaction while the read function call retrieves the value that was written last (without generating a transaction).
</p>


<a name="wp59994"></a><p class="pBody">
The value of the port can be set during construction time by calling the function initialize, e.g.:
</p>


<a name="wp59995"></a><pre class="pCode">     port_a.initialize(false);</pre>


<a name="wp60039"></a><pre class="pCode">     </pre>


<a name="wp59998"></a><p class="pBody">
For a slave port of Signal Protocol a TLM socket of type signal_in is generated. e.g.:
</p>


<a name="wp59999"></a><pre class="pCode">     mb::tlm20::signal_in<span class="cReqRpl">int</span> sig_in;</pre>


<a name="wp60043"></a><pre class="pCode">     </pre>


<a name="wp60002"></a><p class="pBody">
A callback that is called each time the socket gets a transaction is also generated. e.g.:
</p>


<a name="wp60004"></a><pre class="pCode">     void sig_in_callback()</pre>


<a name="wp60005"></a><pre class="pCode">     [</pre>


<a name="wp60006"></a><pre class="pCode">     int variable_a= sig_in.read();</pre>


<a name="wp60007"></a><pre class="pCode">     }</pre>


<a name="wp60047"></a><pre class="pCode">     </pre>


<a name="wp60008"></a><p class="pBody">
The read function call retrieves the value that was written last.
</p>


<a name="wp60010"></a><p class="pBody">
One can also write to such port. The write function call is used to set the value of the port during construction time. It is used in order to set a default value in case the port remains unbound or is not initialized by the master that is bound to it. If both a master and a slave port that are bound together try to initialize their ports, the value set by the master wins.
</p>




<script type="text/javascript" language="JavaScript1.2">
<!--
   PageTitle = "Functions for Master/Slave Ports and Registers";
   PDFLinkTitle = "Functions.for.MasterSlave.Ports.and.Registers"
   ThisTopic = "SignalProtocolModeling";
   CurrentFile = "Chapter_Modeling_Phase23.html";
   MGCSetDocumentVariables();
   MGCUpdateNavPane();
      MGCInsertRTFooter();
 // -->
 </script>



  </body>
</html>
