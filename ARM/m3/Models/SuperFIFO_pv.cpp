
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for SuperFIFO.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.5.0_RedSeaDemo
//* Generated on: Sep. 26, 2012 01:26:54 PM, (user: jon)
//* Automatically merged on: Oct. 02, 2012 12:27:12 PM, (user: jon)
//* Automatically merged on: Jan. 04, 2013 12:29:30 PM, (user: jon)
//*>



#include "SuperFIFO_pv.h"
#include <iostream>
#include <iomanip>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
SuperFIFO_pv::SuperFIFO_pv(sc_module_name module_name) 
  : SuperFIFO_pv_base(module_name) {
  irq.initialize(false);
  ofile.open("SuperFIFO.txt", ios::out);
  ofile << "event;SC_MODULE.SuperFIFO_pv;id;EventField.Long" << endl;
  ofile << "0;SC_MODULE.SuperFIFO_pv;"<< name() <<";Count=0" << endl;
} 

/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a 
// read event on one of the registers as defined in the Model Builder form.
// These functions are called before the read callbacks on the port.
///////////////////////////////////////////////////////////////////////////////// 

// Read callback for d register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int SuperFIFO_pv::cb_read_d() {

  int c;
  unsigned int d_value;

  cout << "        Reading SuperFIFO ";

  if (m_fifo.empty()) {
    d_value = 0;
  } else { 
    d_value = m_fifo.front();
    m_fifo.pop();
    cout << d_value;

    c = m_fifo.size();
    if (c == 0)
      status = 0x05;
    else if (c == 16)
      status = 0x3A; 
    else if (c >= 14) 
      status = 0x1A;
    else if (c >= 8) 
      status = 0xA;
    else if (c <= 2) 
      status = 0x6;
    else 
      status = 0x2;
    count = c;
    Count = c;
    ofile << (uint64) (sc_time_stamp()/sc_time(1,SC_PS)) <<";SC_MODULE.SuperFIFO_pv;"<< name() <<";"<< c << endl;
  }

  cout << endl;
  
  d.setData(d_value);
  return d_value;
}
 

// Read callback for status register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int SuperFIFO_pv::cb_read_status() {
  
  return status;
}
 

// Read callback for clrIRQ register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int SuperFIFO_pv::cb_read_clrIRQ() {
  
  return clrIRQ;
}
  

/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a 
// write event on one of the registers as defined in the Model Builder form.
// These functions are called before the write callbacks on the port.
///////////////////////////////////////////////////////////////////////////////// 

// Write callback for d register.
// The newValue has been already assigned to the d register.
void SuperFIFO_pv::cb_write_d(unsigned int newValue) {

  int c = m_fifo.size();

  if(c < 16) {
    m_fifo.push(newValue);

    c++; 
    if (c == 0) 
      status = 0x05;
    else if (c == 16)
      status = 0x3A;
    else if (c >= 14) {
      status = 0x1A;
      irq.write(true); }
    else if (c >= 8) 
      status = 0xA;
    else if (c <= 2) 
      status = 0x6;
    else 
      status = 0x2;
  } else {
    cout << "Warning: SuperFIFO overflow: Dropped data " << newValue << endl;
  }

  count.setData(c);
  Count = c;
  ofile << (uint64) (sc_time_stamp()/sc_time(1,SC_PS)) <<";SC_MODULE.SuperFIFO_pv;"<< name() <<";"<< c << endl;
}
 

// Write callback for status register.
// The newValue has been already assigned to the status register.
void SuperFIFO_pv::cb_write_status(unsigned int newValue) {

  if (newValue & 0x80000000) {
    count = 0;
    Count = 0;
    status = 0x5;
    ofile << (uint64) (sc_time_stamp()/sc_time(1,SC_PS)) <<";SC_MODULE.SuperFIFO_pv;"<< name() <<";0"<< endl;
    while (!m_fifo.empty()) {
      m_fifo.pop();
    }
  }
}
 

// Write callback for clrIRQ register.
// The newValue has been already assigned to the clrIRQ register.
void SuperFIFO_pv::cb_write_clrIRQ(unsigned int newValue) {
  irq.write(false);
}
  

// Read callback for s port.
// Returns true when successful.
bool SuperFIFO_pv::s_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Write callback for s port.
// Returns true when successful.
bool SuperFIFO_pv::s_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
} 

unsigned SuperFIFO_pv::s_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned SuperFIFO_pv::s_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool SuperFIFO_pv::s_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}


