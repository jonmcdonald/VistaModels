
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for rgb_led.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.4.0
//* Generated on: Sep. 20, 2012 04:49:24 PM, (user: markca)
//*>



#include "rgb_led_pv.h"
#include <iostream>

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
rgb_led_pv::rgb_led_pv(sc_module_name module_name) 
  : rgb_led_pv_base(module_name) {

  /* Setup communication pipeline first */
  if(pipe(commpipe)){
    fprintf(stderr,"Pipe error!\n");
    exit(1);
  }

  /* Attempt to fork and check for errors */
  if( (pid=fork()) == -1){
    fprintf(stderr,"Fork error. Exiting.\n");
    exit(1);        
  }

  if(pid){
    sleep(1);
    close(commpipe[0]);
  }
  else {
    dup2(commpipe[0],0);
    close(commpipe[1]);
    execl("./led/led","led",NULL);
    exit(0);
  }
}    

////////////////////////////////////////
// read callbacks of registers
////////////////////////////////////////// 

unsigned int rgb_led_pv::cb_read_RED_EN()
{
  return 0;
}

unsigned int rgb_led_pv::cb_read_GREEN_EN()
{
  return 0;
}

unsigned int rgb_led_pv::cb_read_BLUE_EN()
{
  return 0;
}
  
/////////////////////////////////////////
// write callbacks of registers
////////////////////////////////////////// 
void rgb_led_pv::cb_write_RED_EN(unsigned int newValue)
{
  printf("RED_EN %d\n", newValue);
  char cmd[10]; 
  sprintf(cmd,"r%d\n", newValue);
  write(commpipe[1], cmd, strlen(cmd));
  vre = newValue;
}

void rgb_led_pv::cb_write_GREEN_EN(unsigned int newValue)
{
  printf("GREEN_EN %d\n", newValue);
  char cmd[10]; 
  sprintf(cmd,"g%d\n", newValue);
  write(commpipe[1], cmd, strlen(cmd));
  vge = newValue;
}

void rgb_led_pv::cb_write_BLUE_EN(unsigned int newValue)
{
  printf("BLUE_EN %d\n", newValue);
  char cmd[10]; 
  sprintf(cmd,"b%d\n", newValue);
  write(commpipe[1], cmd, strlen(cmd));
  vbe = newValue;
}

/////////////////////////////////////////
// ports
////////////////////////////////////////// 

// Read callback for ahb_slave port.
// Returns true when successful.
bool rgb_led_pv::ahb_slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Write callback for ahb_slave port.
// Returns true when successful.
bool rgb_led_pv::ahb_slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
} 




unsigned rgb_led_pv::ahb_slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned rgb_led_pv::ahb_slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool rgb_led_pv::ahb_slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

void rgb_led_pv::cb_transport_dbg_RED_EN(tlm::tlm_generic_payload& trans)
{
}

void rgb_led_pv::cb_transport_dbg_GREEN_EN(tlm::tlm_generic_payload& trans)
{
}

void rgb_led_pv::cb_transport_dbg_BLUE_EN(tlm::tlm_generic_payload& trans)
{
}
