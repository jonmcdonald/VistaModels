
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for controller.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.8.1RND2
//* Generated on: Jul. 24, 2014 01:01:43 PM, (user: markca)
//* Automatically merged on: Jul. 24, 2014 01:02:40 PM, (user: markca)
//*>



#include "controller_pv.h"
#include <iostream>

using namespace sc_core;
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>

using namespace sc_dt;
using namespace std;

//constructor
controller_pv::controller_pv(sc_module_name module_name) 
  : controller_pv_base(module_name) {

  SC_THREAD(server_thread);
}    

void controller_pv::server_thread() {

    int sockfd, newsockfd, portno;
    socklen_t clilen;
    char buffer[256];
    struct sockaddr_in serv_addr, cli_addr;
    int  n;

    /* First call to socket() function */
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) 
    {
        perror("ERROR opening socket");
        exit(1);
    }
    /* Initialize socket structure */
    bzero((char *) &serv_addr, sizeof(serv_addr));
    portno = 5005;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(portno);
 
    /* Now bind the host address using bind() call.*/
    if (bind(sockfd, (struct sockaddr *) &serv_addr,
                          sizeof(serv_addr)) < 0)
    {
         perror("ERROR on binding");
         return;
    }

    /* Now start listening for the clients, here process will
    * go in sleep mode and will wait for the incoming connection
    */
    listen(sockfd,5);
    clilen = sizeof(cli_addr);

    cout << "Controller: Awaiting connection from client on port 5005" << endl;

    /* Accept actual connection from the client */
    newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
    if (newsockfd < 0) 
    {
        perror("ERROR on accept");
        return;
    }

    fcntl(newsockfd, F_SETFL, O_NONBLOCK);

    cout << "Controller: Client connected, awaiting commands" << endl;

    /* If connection is established then start communicating */
    ssize_t bytes_read;
    while(1) {
      wait(100, SC_MS);
      do {
        bzero(buffer, 256);
        bytes_read = recv(newsockfd, buffer, sizeof(buffer), 0);
        if (bytes_read > 0) {
          string cmd(buffer);
          if(cmd.compare("buttonX") == 0) {
            BUTTON_X = 1;
          }
          else if(cmd.compare("buttonY") == 0) {
            BUTTON_Y = 1;
          }
          else if(cmd.compare("buttonZ") == 0) {
            BUTTON_Z = 1;
          }
          flag.write(1);
        } else if(bytes_read == 0) {
          cout << "Controller: Client disconnected, ending simulation" << endl;
          sc_stop();
        }
      } while (bytes_read > 0);
    }
}


// Read callback for buttonX register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int controller_pv::cb_read_BUTTON_X() {
  // reset interrupt line
  flag.write(0);

  return BUTTON_X;
}
 

// Read callback for buttonY register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int controller_pv::cb_read_BUTTON_Y() {
  // reset interrupt line
  flag.write(0);

  return BUTTON_Y;
}
 

// Read callback for buttonZ register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int controller_pv::cb_read_BUTTON_Z() {
  // reset interrupt line
  flag.write(0);

  return BUTTON_Z;
}
   

// Read callback for slave port.
// Returns true when successful.
bool controller_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
}

// Write callback for slave port.
// Returns true when successful.
bool controller_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
} 




unsigned controller_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned controller_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool controller_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

 
void controller_pv::cb_transport_dbg_BUTTON_X(tlm::tlm_generic_payload& trans) {}
void controller_pv::cb_transport_dbg_BUTTON_Y(tlm::tlm_generic_payload& trans) {}
void controller_pv::cb_transport_dbg_BUTTON_Z(tlm::tlm_generic_payload& trans) {}

void  controller_pv::cb_write_BUTTON_X(unsigned int newValue) {
  BUTTON_X = newValue;
}

void  controller_pv::cb_write_BUTTON_Y(unsigned int newValue) {
  BUTTON_Y = newValue;
}

void  controller_pv::cb_write_BUTTON_Z(unsigned int newValue) {
  BUTTON_Z = newValue;
}
