
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for ExternalEventHandler_sc23.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.8.1RND2
//* Generated on: Jul. 25, 2014 02:39:56 PM, (user: markca)
//*>

#include "ExternalEventHandler_sc23_pv.h"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>

#include "DataType.h"

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
ExternalEventHandler_sc23_pv::ExternalEventHandler_sc23_pv(sc_module_name module_name) 
  : ExternalEventHandler_sc23_pv_base(module_name),
    safe_ev("safe_ev")
 {
  int r;
  
  /* First call to socket() function */
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0) 
    {
      perror("ERROR opening socket");
      exit(1);
    }
  /* Initialize socket structure */
  bzero((char *) &serv_addr, sizeof(serv_addr));
  portno = 5005;
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = INADDR_ANY;
  serv_addr.sin_port = htons(portno);
  
  /* Now bind the host address using bind() call.*/
  if (bind(sockfd, (struct sockaddr *) &serv_addr,
           sizeof(serv_addr)) < 0)
    {
      perror("ERROR on binding");
      exit(0);
    }
  
  /* Now start listening for the clients, here process will
   * go in sleep mode and will wait for the incoming connection
   */
  listen(sockfd,5);
  clilen = sizeof(cli_addr);

  cout << "Controller: Awaiting connection from client on port 5005" << endl;

  /* Accept actual connection from the client */
  newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
  if (newsockfd < 0) 
    {
      perror("ERROR on accept");
      exit(0);
    }
  
  SC_THREAD(input);
  SC_THREAD(output);

  r = pthread_create( &readerThread, NULL, &ExternalEventHandler_sc23_pv::call_startReader, this);
  if (r ==0) pthread_detach(readerThread);
}    

// SystemC process which takes data from input and writes out through the tlm port
void ExternalEventHandler_sc23_pv::output() {
  DataType *data;

  while (1) {
    data = fifo.get();
    master_write(0x0, (unsigned char *) data, sizeof(DataType));
  }
}

// SystemC process which waits for asynchronous input from external process
void ExternalEventHandler_sc23_pv::input() {
  DataType *data;

  while (1) {
    wait(safe_ev.default_event());  	// Waits for data from startReader pthread

    // To safely pass data a mutex must be used between startReader and input 
    // protecting each process' modifications of the shared q
    pthread_mutex_lock(&mutex);		
    while (q.size()) {
      data = q.front();		// get the data from the q
      q.pop_front();
      fifo.nb_put(data);	// pass the data to the output process through a tlm_fifo
    }
    pthread_mutex_unlock(&mutex);  // After all data is read from the q release the mutex
  }
}
 

// C++ pthread which will read the socket and wait for input
// from the external process.  It will forward and call notify on safe_ev
void *ExternalEventHandler_sc23_pv::startReader(void) {
  char buffer[256];
  DataType *data;
  
  /* If connection is established then start communicating */
  ssize_t bytes_read;
  while(1) {
    do {
        bzero(buffer, 256);
        cout << "Controller: Client connected, awaiting command" << endl;
        bytes_read = recv(newsockfd, buffer, sizeof(buffer), 0);
        if (bytes_read > 0) {
          string cmd(buffer);
          cout << "Controller: Command " << cmd << " received" << endl;
          
          data = new DataType();	// Create new data structure then fill in values
          data->r = 0;
          data->g = 0;
          data->b = 0;
          
          if(cmd.compare("buttonX") == 0) {
            data->r = 1;
          }
          else if(cmd.compare("buttonY") == 0) {
            data->g = 1;
          }
          else if(cmd.compare("buttonZ") == 0) {
            data->b = 1;
          }
          
          pthread_mutex_lock(&mutex);	// Use mutex to safely modify q
          q.push_back(data);
          safe_ev.notify();			// input SystemC thread is waiting on safe_ev
          pthread_mutex_unlock(&mutex);	// Release mutex when done modifying q
          
        } else if(bytes_read == 0) {
          cout << "Controller: Client disconnected, ending simulation" << endl;
          sc_stop();
          return 0;
        }
      } while (bytes_read > 0);
  }
  return 0;
}



