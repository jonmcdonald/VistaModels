
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for AXI_GPIO.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.8.1RND2
//* Generated on: Aug. 15, 2014 09:39:11 AM, (user: jon)
//* Automatically merged on: Aug. 21, 2014 12:49:26 PM, (user: jon)
//*>

#include "AXI_GPIO_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
AXI_GPIO_pv::AXI_GPIO_pv(sc_module_name module_name) 
  : AXI_GPIO_pv_base(module_name) {
} 

/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a 
// read event on one of the registers as defined in the Model Builder form.
// These functions are called before the read callbacks on the port.
///////////////////////////////////////////////////////////////////////////////// 

// Read callback for IP_ISR register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int AXI_GPIO_pv::cb_read_IP_ISR() {
  
  return IP_ISR;
}
  
/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a 
// write event on one of the registers as defined in the Model Builder form.
// These functions are called before the write callbacks on the port.
///////////////////////////////////////////////////////////////////////////////// 

// Write callback for GPIO_DATA_0 register.
// The newValue has been already assigned to the GPIO_DATA_0 register.
void AXI_GPIO_pv::cb_write_GPIO_DATA_0(unsigned int newValue) {

  if (GPIO_TRI_0 != 0x11111111) {
    m_data0 = (m_data0 & GPIO_TRI_0) | (newValue & ~GPIO_TRI_0);
    if (GPIO_DATA_0 != m_data0) {
      GPIO_DATA_0 = m_data0;
    }
    GPOUT0_write(0x0, m_data0);
  }
}

// Write callback for GPIO_DATA_1 register.
// The newValue has been already assigned to the GPIO_DATA_1 register.
void AXI_GPIO_pv::cb_write_GPIO_DATA_1(unsigned int newValue) {
  
  if (GPIO_TRI_1 != 0x11111111) {
    m_data1 = (m_data1 & GPIO_TRI_1) | (newValue & ~GPIO_TRI_1);
    if (GPIO_DATA_1 != m_data1) {
      GPIO_DATA_1 = m_data1;
      
      GPOUT1_write(0x0, m_data1);
    }
  }
}

// Write callback for IP_ISR register.
// The newValue has been already assigned to the IP_ISR register.
void AXI_GPIO_pv::cb_write_IP_ISR(unsigned int newValue) {
  m_ip_isr = newValue ^ m_ip_isr;
  IP_ISR = m_ip_isr;

  if ((m_ip_isr & 0x3) == 0)
	IRQ.write(0);
}

// Read callback for AXI port.
// Returns true when successful.
bool AXI_GPIO_pv::AXI_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Read callback for GPIN0 port.
// Returns true when successful.
bool AXI_GPIO_pv::GPIN0_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Read callback for GPIN1 port.
// Returns true when successful.
bool AXI_GPIO_pv::GPIN1_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Write callback for AXI port.
// Returns true when successful.
bool AXI_GPIO_pv::AXI_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
} 

// Write callback for GPIN0 port.
// Returns true when successful.
bool AXI_GPIO_pv::GPIN0_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  uint *d = (uint *) data;

  if (GPIO_TRI_0 != 0x00000000) {
    m_data0 = (m_data0 & ~GPIO_TRI_0) | (*d & GPIO_TRI_0);

    if (GPIO_DATA_0 != m_data0) {
      GPIO_DATA_0 = m_data0;
      if ((GIER & 0x80000000) && (IP_IER & 0x1)) {
        IP_ISR = m_ip_isr = m_ip_isr | 0x1;
	IRQ.write(1);
      }
    }
  }
  return true;
} 

// Write callback for GPIN1 port.
// Returns true when successful.
bool AXI_GPIO_pv::GPIN1_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  uint *d = (uint *) data;

  if (GPIO_TRI_1 != 0x00000000) {
    m_data1 = (m_data1 & ~GPIO_TRI_1) | (*d & GPIO_TRI_1);
    if (GPIO_DATA_1 != m_data1) {
      GPIO_DATA_1 = m_data1;
      if ((GIER & 0x80000000) && (IP_IER & 0x2)) {
        IP_ISR = m_ip_isr = m_ip_isr | 0x2;
	IRQ.write(1);
      }
    }
  }
  
  return true;
} 

unsigned AXI_GPIO_pv::AXI_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned AXI_GPIO_pv::AXI_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool AXI_GPIO_pv::AXI_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

unsigned AXI_GPIO_pv::GPIN0_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned AXI_GPIO_pv::GPIN0_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool AXI_GPIO_pv::GPIN0_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

unsigned AXI_GPIO_pv::GPIN1_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned AXI_GPIO_pv::GPIN1_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool AXI_GPIO_pv::GPIN1_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}
 
void AXI_GPIO_pv::cb_transport_dbg_GPIO_DATA_0(tlm::tlm_generic_payload& trans) {}
void AXI_GPIO_pv::cb_transport_dbg_GPIO_DATA_1(tlm::tlm_generic_payload& trans) {}
void AXI_GPIO_pv::cb_transport_dbg_IP_ISR(tlm::tlm_generic_payload& trans) {}

// callback for any change in signal: Resetn of type: sc_in<bool>
void AXI_GPIO_pv::Resetn_callback() {
}
