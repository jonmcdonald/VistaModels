
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for LEDs.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.1beta1
//* Generated on: Mar. 09, 2015 12:01:13 PM, (user: markca)
//*>



#include "LEDs_pv.h"
#include <iostream>
#include <stdint.h>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

#define NUM_LEDS 8
#define LED_RADIUS 16
#define PANEL_WIDTH (NUM_LEDS * LED_RADIUS * 2)
#define PANEL_HEIGHT (LED_RADIUS * 2)

namespace {
class fb_sdl_client : public mb::physical_io::sdl_client {

 public:
  fb_sdl_client(const char* title)
    : sdl_client(title) {
  }

  void kbd_put_keycode(int keycode) {
    ::kbd_put_keycode(keycode);
  }

  int kbd_mouse_is_absolute() {
    return ::kbd_mouse_is_absolute();
  }

  void kbd_mouse_event(int dx, int dy, int dz, int buttons_state) {
    ::kbd_mouse_event(dx, dy, dz, buttons_state);
  }
};
}

//constructor
LEDs_pv::LEDs_pv(sc_core::sc_module_name module_name) 
  : LEDs_pv_base(module_name),
    m_client(0) 
{
  m_client = new fb_sdl_client("Zedboard LEDs");
  m_client->set_size(PANEL_WIDTH, PANEL_HEIGHT);
}    

// Read callback for slave port.
// Returns true when successful.
bool LEDs_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

void LEDs_pv::drawPixel(int x0, int y0)
{
  uint8_t* buffer = m_client->get_buffer();
  int bitsPerPixel = m_client->get_bits_per_pixel();
  int bytesPerPixel = bitsPerPixel / 8;

  uint8_t* write_to = buffer + (x0 * bytesPerPixel) + (y0 * PANEL_WIDTH * bytesPerPixel);
  for(int i = 0; i < bytesPerPixel; i++) {
    *write_to++ = 0xFF;
  }
  
}

void LEDs_pv::horizontalLine(int x1, int y, int x2)
{
  for(int i = x1; i <= x2; i++) {
    drawPixel(i, y);
  }
}

void LEDs_pv::plot4points(int cx, int cy, int x, int y)
{
    horizontalLine(cx - x, cy + y, cx + x);
    if (x != 0 && y != 0)
        horizontalLine(cx - x, cy - y, cx + x);
}    

void LEDs_pv::drawFilledCircle(int cx, int cy, int radius)
{
    int error = -radius;
    int x = radius;
    int y = 0;

    while (x >= y)
    {
        int lastY = y;

        error += y;
        ++y;
        error += y;

        plot4points(cx, cy, x, lastY);

        if (error >= 0)
        {
            if (x != lastY)
                plot4points(cx, cy, lastY, x);

            error -= x;
            --x;
            error -= x;
        }
    }
}

void LEDs_pv::drawCircle(int x0, int y0, int radius)
{
  int x = radius;
  int y = 0;
  int radiusError = 1-x;
 
  while(x >= y)
  {
    drawPixel(x + x0, y + y0);
    drawPixel(y + x0, x + y0);
    drawPixel(-x + x0, y + y0);
    drawPixel(-y + x0, x + y0);
    drawPixel(-x + x0, -y + y0);
    drawPixel(-y + x0, -x + y0);
    drawPixel(x + x0, -y + y0);
    drawPixel(y + x0, -x + y0);
    y++;
    if (radiusError<0)
    {
      radiusError += 2 * y + 1;
    }
    else
    {
      x--;
      radiusError += 2 * (y - x) + 1;
    }
  }
}

void LEDs_pv::clearDisplay()
{
  uint8_t* buffer = m_client->get_buffer();
  int bitsPerPixel = m_client->get_bits_per_pixel();
  int bytesPerPixel = bitsPerPixel / 8;
  memset(buffer, 0, PANEL_WIDTH * PANEL_HEIGHT * bytesPerPixel);
}


#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))

// Write callback for slave port.
// Returns true when successful.
bool LEDs_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  uint32_t input = (uint32_t) *data;

  clearDisplay();

  int l = NUM_LEDS - 1;
  for(int i = 0; i < NUM_LEDS; i++) {
    if(CHECK_BIT(input, i)) {
      drawFilledCircle(LED_RADIUS + ((LED_RADIUS * 2) * l), LED_RADIUS, LED_RADIUS - 1);
    }
    else {
      drawCircle(LED_RADIUS + ((LED_RADIUS * 2) * l), LED_RADIUS, LED_RADIUS - 1);
    }
    l--;
  }
  m_client->update(0, 0, PANEL_WIDTH, PANEL_HEIGHT);

  return true;
} 

unsigned LEDs_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned LEDs_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool LEDs_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

 
