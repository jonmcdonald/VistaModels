
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for Timer.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.2.1
//* Generated on: Nov. 01, 2016 11:08:42 AM, (user: markca)
//*>


#include "Timer_pv.h"
#include <iostream>

//constructor
Timer_pv::Timer_pv(sc_module_name module_name) 
  : Timer_pv_base(module_name),
  m_count(0) {
  SC_METHOD(timer_func);
  sensitive << m_timer_event;
  //  dont_initialize () ;
  irq.initialize(true);
}

void Timer_pv::cb_write_clear_irq(unsigned int newValue) {
  
  irq.write(true); //writing to the output signal
}

void Timer_pv::cb_write_restart(unsigned int newValue) {

  m_count = Timer_pv_base::int_count;
  if (m_count > 0) {
    m_timer_event.notify_delayed((config::real80)clock_period * clock_count, SC_PS);
  }
}

// Read callback for host port.cb_read_IRQStatus
// Return true when successful.
bool Timer_pv::host_callback_read(config::uint64 address, unsigned char* data, unsigned size) {
  
  return true;
}


// Write callback for host port.
// Return true when successful.
bool Timer_pv::host_callback_write(config::uint64 address, unsigned char* data, unsigned size) {
  
  return true;
}


void Timer_pv::timer_func() {
  irq.write(false); //writing to the output signal
  // The timer waits for clear_irq or restart to continue working
  m_count--;
  if (m_count > 0) {
    m_timer_event.notify_delayed((config::real80)clock_period * clock_count.getData(), SC_PS);
  }
}

