/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for sink.
//* This is a template file: You may modify this file to implement the
//* behavior of your component.
//*
//* Model Builder version: 3.2.0RC
//* Generated on: Feb. 23, 2012 07:58:11 AM, (user: jon)
//*>


#include "sink_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
sink_pv::sink_pv(sc_module_name module_name)
    : sink_pv_base(module_name)
{
}

bool sink_pv::general_write(mb_address_type address, unsigned char* data, unsigned size,
                            const char* extra)
{
    mb::mb_token_ptr tokenptr = get_current_token();
    int *d = (int *) data;

    if(tokenptr && tokenptr->hasField("CreateTime")) {
        cout << sc_simulation_time() << ":" << name() << " " << extra << " receiving data = " << d[0] << " *** ";
        cout << "Lifetime = " << sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime") << endl;
        switch (extra[1]) {
        case '1' : LifeTime1 = (sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime")) / clock; break;
        case '2' : LifeTime2 = (sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime")) / clock; break;
        case '3' : LifeTime3 = (sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime")) / clock; break;
        case '4' : LifeTime4 = (sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime")) / clock; break;
        case '5' : LifeTime5 = (sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime")) / clock; break;
        case '6' : LifeTime6 = (sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime")) / clock; break;
        case '7' : LifeTime7 = (sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime")) / clock; break;
        case '8' : LifeTime8 = (sc_time_stamp() - tokenptr->getFieldAsTime("CreateTime")) / clock; break; }
        
    }
    return true;
}

bool sink_pv::slave_1_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_write(address, data, size, "[1]");
}

bool sink_pv::slave_2_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_write(address, data, size, "[2]");
}

bool sink_pv::slave_3_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_write(address, data, size, "[3]");
}

bool sink_pv::slave_4_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_write(address, data, size, "[4]");
}

bool sink_pv::slave_5_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_write(address, data, size, "[5]");
}

bool sink_pv::slave_6_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_write(address, data, size, "[6]");
}

bool sink_pv::slave_7_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_write(address, data, size, "[7]");
}

bool sink_pv::slave_8_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_write(address, data, size, "[8]");
}


