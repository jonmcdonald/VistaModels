
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for driver.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.7.0
//* Generated on: Oct. 19, 2013 09:49:15 AM, (user: jon)
//*>



#include "driver_pv.h"
#include <iostream>

#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
driver_pv::driver_pv(sc_module_name module_name) 
  : driver_pv_base(module_name),
    safe_ev("safe_ev")
 {
  int r;

  SC_THREAD(input);
  SC_THREAD(output);

  r = pthread_create( &readerThread, NULL, &driver_pv::call_startReader, this);
  if (r ==0) pthread_detach(readerThread);
}    

// SystemC process which takes data from input and writes out through the tlm port
void driver_pv::output() {
  DataType *data;

  while (1) {
    data = fifo.get();
    y_write(0x0, (unsigned char *) data, sizeof(DataType));
  }
}

// SystemC process which waits for asynchronous input from external process
void driver_pv::input() {
  DataType *data;

  while (1) {
    wait(safe_ev.default_event());  	// Waits for data from startReader pthread

    // To safely pass data a mutex must be used between startReader and input 
    // protecting each process' modifications of the shared q
    pthread_mutex_lock(&mutex);		
    while (q.size()) {
      data = q.front();		// get the data from the q
      q.pop_front();
      fifo.nb_put(data);	// pass the data to the output process through a tlm_fifo
    }
    pthread_mutex_unlock(&mutex);  // After all data is read from the q release the mutex
  }
}
 

// C++ pthread which will fork and exec the external process then wait for input
// from the external process.  It will forward and call notify on safe_ev
void *driver_pv::startReader(void) {
  int fd;
  string myFifoPipe = ".tmpFifoPipe.";  // Base name for named pipe
  char buf[1024];
  int num;
  DataType *data;

  myFifoPipe.append(name());		// Append unique instance name to name of pipe
  mkfifo(myFifoPipe.c_str(), 0666);	// Create named pipe in startup directory

  pid_t pID = fork();
  if (pID == 0) {	//child
    // Execute the writer program passing the name of the pipe as an argument
    execlp("xterm", "xterm", "-e", "./writer", myFifoPipe.c_str(), (char *) 0);
    exit(0);
  }
  else if (pID < 0) {	// failed to fork
    cerr << "Error: driver_pv::startReader failed to fork process." << endl;
  }
  else {		//parent: open, read, and display the message from the FIFO
    fd = open(myFifoPipe.c_str(), O_RDONLY);

    while ( (num = read(fd, buf, 1024)) > 0 ) {
      buf[num] = '\0';
      //printf("Received: %s\n", buf);

      data = new DataType();	// Create new data structure then fill in values
      sscanf(buf, "%d %d %d", &data->id, &data->x, &data->y);

      pthread_mutex_lock(&mutex);	// Use mutex to safely modify q
      q.push_back(data);
      safe_ev.notify();			// input SystemC thread is waiting on safe_ev
      pthread_mutex_unlock(&mutex);	// Release mutex when done modifying q
    }
    close(fd);
  }
  return 0;
}
