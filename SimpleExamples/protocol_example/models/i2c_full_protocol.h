
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/


/* Generated by Model Builder  */

#pragma once
#ifndef __i2c_full_h__
#define __i2c_full_h__

#include "model_builder.h"
class i2c_full_extension : public tlm::tlm_extension<i2c_full_extension> {
    public:
        int m_start_stop;
        bool m_ack_nack;
        
        //virtual functions of tlm::tlm_extension
        virtual tlm_extension_base* clone() const {
          i2c_full_extension* ext = new i2c_full_extension();
          ext->m_start_stop = m_start_stop;
          ext->m_ack_nack = m_ack_nack;
          return ext;
        }
        
        virtual void copy_from(tlm_extension_base const & other) {
          const i2c_full_extension& ext = dynamic_cast<const i2c_full_extension&>(other);
          m_start_stop = ext.m_start_stop;
          m_ack_nack = ext.m_ack_nack;
        }
};

class i2c_full_payload : public tlm::tlm_generic_payload {
    public:
        i2c_full_payload() { 
          set_extension(new i2c_full_extension()); 
        }
        ~i2c_full_payload() { 
        }
        
    public:
        inline void set_start_stop(int start_stop) {
          i2c_full_extension* ext = NULL;
          get_extension(ext);
          assert(ext);
          ext->m_start_stop = start_stop;
        }
        inline void set_ack_nack(bool ack_nack) {
          i2c_full_extension* ext = NULL;
          get_extension(ext);
          assert(ext);
          ext->m_ack_nack = ack_nack;
        }
    
    public:
        inline int get_start_stop() const {
          i2c_full_extension* ext = NULL;
          get_extension(ext);
          assert(ext);
          return ext->m_start_stop;
        }
        inline bool get_ack_nack() const {
          i2c_full_extension* ext = NULL;
          get_extension(ext);
          assert(ext);
          return ext->m_ack_nack;
        }
};
class i2c_full_blocking_if : public virtual sc_core::sc_interface
{
public:
  virtual void READ(sc_dt::uint64 delay, long start_stop, long ack_nack) = 0;
  virtual void WRITE(sc_dt::uint64 delay, long start_stop, long ack_nack) = 0;
  virtual sc_dt::uint64 getClock() = 0;
};

class i2c_full_non_blocking_if : public virtual sc_core::sc_interface
{
public:
  virtual void nb_READ(sc_dt::uint64 delay, long start_stop, long ack_nack) = 0;
  virtual void nb_WRITE(sc_dt::uint64 delay, long start_stop, long ack_nack) = 0;
  virtual const PapoulisEvent& endTransaction() = 0;
  virtual const PapoulisEvent& endAllTransactions() = 0;
  virtual bool canInitiateTransaction() = 0;
  virtual sc_dt::uint64 getClock() = 0;
};

struct i2c_full_protocol_types{
  typedef tlm::tlm_generic_payload tlm_payload_type;
  typedef tlm::tlm_phase tlm_phase_type;
};
#endif
