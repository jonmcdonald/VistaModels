
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for FAULT.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.2.1
//* Generated on: Aug. 09, 2016 11:44:05 AM, (user: markca)
//*>



#include "FAULT_pv.h"
                                      //#include "mb_include/esl/sc_sim/AccessMbInterface.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;
using namespace mb;

//constructor
FAULT_pv::FAULT_pv(sc_module_name module_name) 
  : FAULT_pv_base(module_name) {
   SC_THREAD(thread);
}      

 
// in order to minimize merging conflicts, we recommend to add your functions after this comment
// This thread can be used to generate outgoing transactions
void FAULT_pv::thread() {

  //Creating an access object in order to create handles:  
  AccessMbInterface acc = mb::AccessMbInterface::getAccessMbInterface();
 
  //Creating handles to sc_objects:
  sc_core::sc_object* handle_reg0 = acc.get_mb_register_handle("top.uart.PV.RBR_THR_DLL");
  sc_core::sc_object* handle_irq  = acc.get_mb_signal_object_handle("top.ic.PV.Internal0");

  acc.set_external_write_callback(handle_irq, FAULT_pv::my_cb);

  while(1) {
    cout << name() << " @ " << sc_time_stamp() << "  UART IRQ: Running Normally" << endl;
    wait(5, SC_SEC);
    cout << name() << " @ " << sc_time_stamp() << "  UART IRQ: Blocking with 0" << endl;
    sc_core::sc_spawn(sc_bind(&FAULT_pv::irqZeroThread, handle_irq, 5, SC_SEC));  
    wait(5, SC_SEC);
    (acc.get_stop_event(handle_irq)).notify();
  }
  
}   

void FAULT_pv::irqZeroThread(sc_core::sc_object* object_handle, double time, sc_core::sc_time_unit time_unit) {
  sc_core::sc_time t_wait = sc_core::sc_time(time, time_unit);
  sc_core::sc_time t1 = sc_core::sc_time(0, time_unit);
  sc_core::sc_time t2 = sc_core::sc_time(0, time_unit);
  t1 = sc_core::sc_time_stamp();
  unsigned long long toSend;
  unsigned long long g, f;
  bool first = false;
  while(1){
    sc_core::wait(time, time_unit,
                  AccessMbInterface::getAccessMbInterface().get_write_event(object_handle) | 
                  AccessMbInterface::getAccessMbInterface().get_stop_event(object_handle));

    t2 = sc_core::sc_time_stamp();
    if (t_wait <= (t2-t1))
      break;

    g = AccessMbInterface::getAccessMbInterface().get_value(object_handle);
    if(! first) {
      first = true;
      f = g;
    }
    toSend = 0;
    AccessMbInterface::getAccessMbInterface().set_value(object_handle, toSend);
    cout << "UART IRQ: Blocked " << g << " Sending " << toSend << endl;
  }
  if(first && (toSend != f)) {
    AccessMbInterface::getAccessMbInterface().set_value(object_handle, f);
    cout << "UART IRQ: Resetting to " << f << " from " << toSend << endl;
  }
}

void FAULT_pv::my_cb(sc_core::sc_object* object_handle){
  if (!AccessMbInterface::getAccessMbInterface().get_external_write_flag(object_handle)) {
    (AccessMbInterface::getAccessMbInterface().get_write_event(object_handle)).notify();
  }
}
