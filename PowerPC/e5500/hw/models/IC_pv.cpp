
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for IC.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.9Beta1
//* Generated on: May. 19, 2014 08:13:02 PM, (user: nlevy)
//* Automatically merged on: May. 20, 2014 05:30:42 PM, (user: nlevy)
//* Automatically merged on: May. 20, 2014 05:37:03 PM, (user: nlevy)
//* Automatically merged on: May. 25, 2014 02:50:32 PM, (user: nlevy)
//* Automatically merged on: May. 25, 2014 04:36:46 PM, (user: nlevy)
//* Automatically merged on: May. 25, 2014 04:42:18 PM, (user: nlevy)
//* Automatically merged on: Aug. 05, 2014 06:21:11 PM, (user: ibirger)
//* Automatically merged on: Mar. 16, 2016 02:46:59 PM, (user: nlevy)
//*>



#include "IC_pv.h"
#include "IC_pv.h"
#include <iostream>
#include <bitset>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
IC_pv::IC_pv(sc_module_name module_name) 
  : IC_pv_base(module_name) {
  init();
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

#define OPENPIC_GLB_REG_START        0x0
#define OPENPIC_GLB_REG_SIZE         0x10F0
#define OPENPIC_TMR_REG_START        0x10F0
#define OPENPIC_TMR_REG_SIZE         0x220
#define OPENPIC_MSI_REG_START        0x1600
#define OPENPIC_MSI_REG_SIZE         0x200
#define OPENPIC_SUMMARY_REG_START    0x3800
#define OPENPIC_SUMMARY_REG_SIZE     0x800
#define OPENPIC_SRC_REG_START        0x10000
#define OPENPIC_SRC_REG_SIZE         0x10000//(OPENPIC_MAX_SRC * 0x20)
#define OPENPIC_CPU_REG_START        0x20000
#define OPENPIC_CPU_REG_SIZE         0x10000//0x100 + ((MAX_CPU - 1) * 0x1000)


#define TBCR_CI           0x80000000 /* count inhibit */
#define TCCR_TOG          0x80000000 /* toggles when decrement to zero */


/* Following definition is copied from linux-3.0rc1/include/linux/kernel.h */
///roms/ipxe/src/drivers/net/tg3/tg3.h
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
/* bitops.h */
#define BITS_PER_BYTE           8
#undef BITS_PER_LONG
#define BITS_PER_LONG           32
//(sizeof (uint32_t) * BITS_PER_BYTE)
#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(uint32_t))
#define BIT_MASK(nr)		(1U << ((nr) % BITS_PER_LONG))
#define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
#define BITOP_WORD(nr)		((nr) / BITS_PER_LONG)

#define IVPR_MASK_SHIFT       31
#define IVPR_MASK_MASK        (1U << IVPR_MASK_SHIFT)
#define IVPR_ACTIVITY_SHIFT   30
#define IVPR_ACTIVITY_MASK    (1U << IVPR_ACTIVITY_SHIFT)
#define IVPR_MODE_SHIFT       29
#define IVPR_MODE_MASK        (1U << IVPR_MODE_SHIFT)
#define IVPR_POLARITY_SHIFT   23
#define IVPR_POLARITY_MASK    (1U << IVPR_POLARITY_SHIFT)
#define IVPR_SENSE_SHIFT      22
#define IVPR_SENSE_MASK       (1U << IVPR_SENSE_SHIFT)

#define IDR_EP_SHIFT      31

/* IDR[EP/CI] are only for FSL MPIC prior to v4.0 */
#define IDR_EP      0x80000000  /* external pin */
#define IDR_CI      0x40000000  /* critical interrupt */

#define IDR_CI0_SHIFT     30
#define OPENPIC_FLAG_IDR_CRIT     (1 << 0)

#define IVPR_PRIORITY_MASK     (0xFU << 16)
#define IVPR_PRIORITY(_ivprr_) ((int)(((_ivprr_) & IVPR_PRIORITY_MASK) >> 16))
#define IVPR_VECTOR(opp, _ivprr_) ((_ivprr_) & (opp)->vector_mask)

typedef enum IRQType {
    IRQ_TYPE_NORMAL = 0,
    IRQ_TYPE_FSLINT,        /* FSL internal interrupt -- level only */
    IRQ_TYPE_FSLSPECIAL,    /* FSL timer/IPI interrupt, edge, no polarity */
} IRQType;

typedef struct IRQQueue {
    /* Round up to the nearest 64 IRQs so that the queue length
     * won't change when moving between 32 and 64 bit hosts.
     */
    uint32_t queue[BITS_TO_LONGS((OPENPIC_MAX_IRQ + 63) & ~63)];
    int next;
    int priority;
} IRQQueue;

typedef struct IRQSource {
    uint32_t ivpr;  /* IRQ vector/priority register */
    uint32_t idr;   /* IRQ destination register */
    uint32_t destmask; /* bitmap of CPU destinations */
    int last_cpu;
    int output;     /* IRQ level, e.g. OPENPIC_OUTPUT_INT */
    int pending;    /* TRUE if IRQ is pending */
    IRQType type;
    bool level:1;   /* level-triggered */
    bool nomask:1;  /* critical interrupts ignore mask on some FSL MPICs */
} IRQSource;

typedef void (*qemu_irq_handler)(void *opaque, int n, int level);
struct IRQState {
    qemu_irq_handler handler;
    void *opaque;
    int n;
};
typedef struct IRQState *qemu_irq;
typedef struct IRQDest {
    int32_t ctpr; /* CPU current task priority */
    IRQQueue raised;
    IRQQueue servicing;
    qemu_irq *irqs;

    /* Count of IRQ sources asserting on non-INT outputs */
    uint32_t outputs_active[OPENPIC_OUTPUT_NB];
} IRQDest;

typedef struct FslMpicInfo {
    int max_ext;
} FslMpicInfo;

FslMpicInfo fsl_mpic_42;


class OpenPICState {
public:
    /*< private >*/
  //    SysBusDevice parent_obj;
    /*< public >*/

  //    MemoryRegion mem;

    /* Behavior control */
    FslMpicInfo *fsl;
    uint32_t model;
    uint32_t flags;
    uint32_t nb_irqs;
    uint32_t vid;
    uint32_t vir; /* Vendor identification register */
    uint32_t vector_mask;
    uint32_t tfrr_reset;
    uint32_t ivpr_reset;
    uint32_t idr_reset;
    uint32_t brr1;
    uint32_t mpic_mode_mask;

    /* Sub-regions */
  //    MemoryRegion sub_io_mem[6];

    /* Global registers */
    uint32_t frr; /* Feature reporting register */
    uint32_t gcr; /* Global configuration register  */
    uint32_t pir; /* Processor initialization register */
    uint32_t spve; /* Spurious vector register */
    uint32_t tfrr; /* Timer frequency reporting register */
    /* Source registers */
    IRQSource src[OPENPIC_MAX_IRQ];
    /* Local registers per output pin */
    IRQDest dst[MAX_CPU];
    uint32_t nb_cpus;
    /* Timer registers */
    struct {
        uint32_t tccr;  /* Global timer current count register */
        uint32_t tbcr;  /* Global timer base count register */
    } timers[OPENPIC_MAX_TMR];
    /* Shared MSI registers */
    struct {
        uint32_t msir;   /* Shared Message Signaled Interrupt Register */
    } msi[MAX_MSI];
    uint32_t max_irq;
    uint32_t irq_ipi0;
    uint32_t irq_tim0;
    uint32_t irq_msi;
};

OpenPICState OppState;
/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a  
// write/read event on one of memory io ranges as defined in the Model Builder form.
///////////////////////////////////////////////////////////////////////////////// 
static void fsl_common_init(OpenPICState *opp)
{
    int i;
    int virq = OPENPIC_MAX_SRC;

    opp->vid = VID_REVISION_1_2;
    opp->vir = VIR_GENERIC;
    opp->vector_mask = 0xFFFF;
    opp->tfrr_reset = 0;
    opp->ivpr_reset = IVPR_MASK_MASK;
    opp->idr_reset = 1 << 0;
    opp->max_irq = OPENPIC_MAX_IRQ;

    opp->irq_ipi0 = virq;
    virq += OPENPIC_MAX_IPI;
    opp->irq_tim0 = virq;
    virq += OPENPIC_MAX_TMR;

    assert(virq <= OPENPIC_MAX_IRQ);

    opp->irq_msi = 224;

    //    msi_supported = true;
    for (i = 0; i < opp->fsl->max_ext; i++) {
        opp->src[i].level = false;
    }

    /* Internal interrupts, including message and MSI */
    for (i = 16; i < OPENPIC_MAX_SRC; i++) {
        opp->src[i].type = IRQ_TYPE_FSLINT;
        opp->src[i].level = true;
        opp->src[i].destmask = 0x1;//reset accourding to documentation.
    }

    /* timers and IPIs */
    for (i = OPENPIC_MAX_SRC; i < virq; i++) {
        opp->src[i].type = IRQ_TYPE_FSLSPECIAL;
        opp->src[i].level = false;
    }
}
void IC_pv::reset(OpenPICState *opp)
{
    int i;

    opp->gcr = GCR_RESET;
    /* Initialise controller registers */
    opp->frr = ((opp->nb_irqs - 1) << FRR_NIRQ_SHIFT) |
               ((opp->nb_cpus - 1) << FRR_NCPU_SHIFT) |
               (opp->vid << FRR_VID_SHIFT);

    opp->pir = 0;
    opp->spve = -1 & opp->vector_mask;
    opp->tfrr = opp->tfrr_reset;
    /* Initialise IRQ sources */
    for (i = 0; i < opp->max_irq; i++) {
        opp->src[i].ivpr = opp->ivpr_reset;
        opp->src[i].idr  = opp->idr_reset;

        switch (opp->src[i].type) {
        case IRQ_TYPE_NORMAL:
            opp->src[i].level = !!(opp->ivpr_reset & IVPR_SENSE_MASK);
            break;

        case IRQ_TYPE_FSLINT:
            opp->src[i].ivpr |= IVPR_POLARITY_MASK;
            break;

        case IRQ_TYPE_FSLSPECIAL:
            break;
        }
    }
    /* Initialise IRQ destinations */
    for (i = 0; i < MAX_CPU; i++) {
        opp->dst[i].ctpr      = 15;
        memset(&opp->dst[i].raised, 0, sizeof(IRQQueue));
        opp->dst[i].raised.next = -1;
        memset(&opp->dst[i].servicing, 0, sizeof(IRQQueue));
        opp->dst[i].servicing.next = -1;
    }
    /* Initialise timers */
    for (i = 0; i < OPENPIC_MAX_TMR; i++) {
        opp->timers[i].tccr = 0;
        opp->timers[i].tbcr = TBCR_CI;
    }
    /* Go out of RESET state */
    opp->gcr = 0;
}

void IC_pv::init()
{
  int i,j;
  OppState.nb_cpus = 1; //raw qemu 2.0 supports only one? cpu openpic_properties. TODON
  OppState.max_irq = 0;
  fsl_mpic_42.max_ext = 12;
  OppState.fsl = &fsl_mpic_42;
  OppState.brr1 = 0x00400402;
  OppState.flags |= OPENPIC_FLAG_ILR;
  OppState.nb_irqs = 196;
  OppState.mpic_mode_mask = GCR_MODE_PROXY;

  fsl_common_init(&OppState);
  for (i = 0; i < OppState.nb_cpus; i++) {
    OppState.dst[i].irqs = (qemu_irq*)malloc ( OPENPIC_OUTPUT_NB * sizeof(qemu_irq *)); //TODON add free
    for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {
      OppState.dst[i].irqs[j] = (qemu_irq)malloc ( sizeof(IRQState) ); //TODON add free
    }
    //consider use TODON
    //    OppState.dst[i].irqs[OPENPIC_OUTPUT_INT].    /* IRQ                       */
    //    OppState.dst[i].irqs[OPENPIC_OUTPUT_CINT].   /* critical IRQ              */
    //    OppState.dst[i].irqs[OPENPIC_OUTPUT_MCK].    /* Machine check event       */
    //    OppState.dst[i].irqs[OPENPIC_OUTPUT_DEBUG]  /* Inconditional debug event */
    //    OppState.dst[i].irqs[OPENPIC_OUTPUT_RESET]  /* Core reset event          */

  }
 reset(&OppState);

  
}
/*
bool IACK_read_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) 
{
  return true;
} 
*/

bool IC_pv::IACK_read_callback_read(mb_address_type address,
                                    unsigned char* data,
                                    unsigned size) {
  //address currently not used because interface used only for EPR
    int cpu           = get_current_cpu();
    OpenPICState *opp = &OppState;
    IRQDest *dst     =  &opp->dst[cpu];

    uint32_t val = openpic_iack(opp, dst, cpu);
    memcpy(data, &val, sizeof(uint32_t));

    return true;
 } 
// Write callback for global_reg memory range.
void IC_pv::cb_write_global_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    IRQDest *dst;
    int idx;
    uint32_t val;
    union u
    {
      uint32_t val;
      char     array[sizeof(uint32_t)];
    }u;

    memcpy(u.array, data, length);
    val = u.val;

    //    DPRINTF("%s: addr %#" UINT64_T_PRIx " <= %08" PRIx64 "\n",
    //            __func__, addr, val);
    if (address & 0xF) {
        return;
    }
    switch (address) {
    case 0x00: /* Block Revision Register1 (BRR1) is Readonly */
        break;
    case 0x40:
    case 0x50:
    case 0x60:
    case 0x70:
    case 0x80:
    case 0x90:
    case 0xA0:
    case 0xB0:
        openpic_cpu_write_internal(opp, address, val, get_current_cpu());
        break;
    case 0x1000: /* FRR */
        break;
    case 0x1020: /* GCR */
        openpic_gcr_write(opp, val);
        break;
    case 0x1080: /* VIR */
        break;
    case 0x1090: /* PIR */
        for (idx = 0; idx < opp->nb_cpus; idx++) {
            if ((val & (1 << idx)) && !(opp->pir & (1 << idx))) {
              //DPRINTF("Raise OpenPIC RESET output for CPU %d\n", idx);
                dst = &opp->dst[idx];
                //                qemu_irq_raise(dst->irqs[OPENPIC_OUTPUT_RESET]);
                //                qemu_set_irq(dst->irqs[OPENPIC_OUTPUT_RESET],1);
                set_irq(OPENPIC_OUTPUT_RESET, 1);
            } else if (!(val & (1 << idx)) && (opp->pir & (1 << idx))) {
              //DPRINTF("Lower OpenPIC RESET output for CPU %d\n", idx);
                dst = &opp->dst[idx];
                //                qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_RESET]);
                //                qemu_set_irq(dst->irqs[OPENPIC_OUTPUT_RESET],0);
                set_irq(OPENPIC_OUTPUT_RESET, 0);
            }
        }
        opp->pir = val;
        break;
    case 0x10A0: /* IPI_IVPR */
    case 0x10B0:
    case 0x10C0:
    case 0x10D0:
        {
            int idx;
            idx = (address - 0x10A0) >> 4;
            write_IRQreg_ivpr(opp, opp->irq_ipi0 + idx, val);
        }
        break;
    case 0x10E0: /* SPVE */
        opp->spve = val & opp->vector_mask;
        break;
    default:
        break;
    }  
  
}
uint32_t IC_pv::read_IRQreg_ivpr(OpenPICState *opp, int n_IRQ)
{
    return opp->src[n_IRQ].ivpr;
}

uint32_t IC_pv::openpic_iack(OpenPICState *opp, IRQDest *dst, int cpu)
{
    IRQSource *src;
    int retval, irq;

    //    DPRINTF("Lower OpenPIC INT output\n");
    //    qemu_set_irq(dst->irqs[OPENPIC_OUTPUT_INT],0);
    set_irq(OPENPIC_OUTPUT_INT, 0);

    irq = IRQ_get_next(opp, &dst->raised);
    //    DPRINTF("IACK: irq=%d\n", irq);

    if (irq == -1) {
        /* No more interrupt pending */
        return opp->spve;
    }

    src = &opp->src[irq];
    if (!(src->ivpr & IVPR_ACTIVITY_MASK) ||
            !(IVPR_PRIORITY(src->ivpr) > dst->ctpr)) {
      //        fprintf(stderr, "%s: bad raised IRQ %d ctpr %d ivpr 0x%08x\n",
      //                __func__, irq, dst->ctpr, src->ivpr);
        openpic_update_irq(opp, irq);
        retval = opp->spve;
    } else {
        /* IRQ enter servicing state */
        IRQ_setbit(&dst->servicing, irq);
        retval = IVPR_VECTOR(opp, src->ivpr);
    }

    if (!src->level) {
        /* edge-sensitive IRQ */
        src->ivpr &= ~IVPR_ACTIVITY_MASK;
        src->pending = 0;
        IRQ_resetbit(&dst->raised, irq);
    }

    if ((irq >= opp->irq_ipi0) &&  (irq < (opp->irq_ipi0 + OPENPIC_MAX_IPI))) {
        src->destmask &= ~(1 << cpu);
        if (src->destmask && !src->level) {
            /* trigger on CPUs that didn't know about it yet */
            openpic_set_irq(opp, irq, 1);
            openpic_set_irq(opp, irq, 0);
            /* if all CPUs knew about it, set active bit again */
            src->ivpr |= IVPR_ACTIVITY_MASK;
        }
    }

    return retval;
}


uint32_t IC_pv::openpic_cpu_read_internal(void *opaque, uint64_t addr,
                                          int idx)
{
    OpenPICState *opp = &OppState;
    IRQDest *dst;
    uint32_t retval;

    //    DPRINTF("%s: cpu %d addr %#" HWADDR_PRIx "\n", __func__, idx, addr);
    retval = 0xFFFFFFFF;

    if (idx < 0) {
        return retval;
    }

    if (addr & 0xF) {
        return retval;
    }
    dst = &opp->dst[idx];
    addr &= 0xFF0;
    switch (addr) {
    case 0x80: /* CTPR */
        retval = dst->ctpr;
        break;
    case 0x90: /* WHOAMI */
        retval = idx;
        break;
    case 0xA0: /* IACK */
        retval = openpic_iack(opp, dst, idx);
        break;
    case 0xB0: /* EOI */
        retval = 0;
        break;
    default:
        break;
    }
    //    DPRINTF("%s: => 0x%08x\n", __func__, retval);

    return retval;
}

// Read callback for global_reg memory range.
void IC_pv::cb_read_global_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    uint32_t retval;

    //    DPRINTF("%s: address %#" HWADDR_PRIx "\n", __func__, addr);
    retval = 0xFFFFFFFF;
    if (address & 0xF) {
      return ;//retval;
    }
    switch (address) {
    case 0x1000: /* FRR */
        retval = opp->frr;
        break;
    case 0x1020: /* GCR */
        retval = opp->gcr;
        break;
    case 0x1080: /* VIR */
        retval = opp->vir;
        break;
    case 0x1090: /* PIR */
        retval = 0x00000000;
        break;
    case 0x00: /* Block Revision Register1 (BRR1) */
        retval = opp->brr1;
        break;
    case 0x40:
    case 0x50:
    case 0x60:
    case 0x70:
    case 0x80:
    case 0x90:
    case 0xA0:
    case 0xB0:
        retval = openpic_cpu_read_internal(opp, address, get_current_cpu());
        break;
    case 0x10A0: /* IPI_IVPR */
    case 0x10B0:
    case 0x10C0:
    case 0x10D0:
        {
            int idx;
            idx = (address - 0x10A0) >> 4;
            retval = read_IRQreg_ivpr(opp, opp->irq_ipi0 + idx);
        }
        break;
    case 0x10E0: /* SPVE */
        retval = opp->spve;
        break;
    default:
        break;
    }
    //    DPRINTF("%s: => 0x%08x\n", __func__, retval);

    //    return retval;
    memcpy(data, &retval, length);
}
 

// Write callback for tmr_reg memory range.
void IC_pv::cb_write_tmr_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    IRQDest *dst;
    int idx;
    uint32_t val;
    union u
    {
      uint32_t val;
      char     array[sizeof(uint32_t)];
    }u;

    memcpy(u.array, data, length);
    val = u.val;

    address += 0x10f0;

    //    DPRINTF("%s: addr %#" HWADDR_PRIx " <= %08" PRIx64 "\n",
    //            __func__, addr, val);
    if (address & 0xF) {
        return;
    }

    if (address == 0x10f0) {
        /* TFRR */
        opp->tfrr = val;
        return;
    }

    idx = (address >> 6) & 0x3;
    address = address & 0x30;

    switch (address & 0x30) {
    case 0x00: /* TCCR */
        break;
    case 0x10: /* TBCR */
        if ((opp->timers[idx].tccr & TCCR_TOG) != 0 &&
            (val & TBCR_CI) == 0 &&
            (opp->timers[idx].tbcr & TBCR_CI) != 0) {
            opp->timers[idx].tccr &= ~TCCR_TOG;
        }
        opp->timers[idx].tbcr = val;
        break;
    case 0x20: /* TVPR */
        write_IRQreg_ivpr(opp, opp->irq_tim0 + idx, val);
        break;
    case 0x30: /* TDR */
        write_IRQreg_idr(opp, opp->irq_tim0 + idx, val);
        break;
    }  
}

uint32_t IC_pv::read_IRQreg_idr(OpenPICState *opp, int n_IRQ)
{
    return opp->src[n_IRQ].idr;
}

// Read callback for tmr_reg memory range.
void IC_pv::cb_read_tmr_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    uint32_t retval = -1;
    int idx;

    //    DPRINTF("%s: addr %#" HWADDR_PRIx "\n", __func__, addr);
    if (address & 0xF) {
        goto out;
    }
    idx = (address >> 6) & 0x3;
    if (address == 0x0) {
        /* TFRR */
        retval = opp->tfrr;
        goto out;
    }
    switch (address & 0x30) {
    case 0x00: /* TCCR */
        retval = opp->timers[idx].tccr;
        break;
    case 0x10: /* TBCR */
        retval = opp->timers[idx].tbcr;
        break;
    case 0x20: /* TIPV */
        retval = read_IRQreg_ivpr(opp, opp->irq_tim0 + idx);
        break;
    case 0x30: /* TIDE (TIDR) */
        retval = read_IRQreg_idr(opp, opp->irq_tim0 + idx);
        break;
    }

out:
    //    DPRINTF("%s: => 0x%08x\n", __func__, retval);

    //    return retval;
    memcpy(data, &retval, length);
}
 
#define MSIIR_OFFSET       0x140
#define MSIIR_SRS_SHIFT    29
#define MSIIR_SRS_MASK     (0x7 << MSIIR_SRS_SHIFT)
#define MSIIR_IBS_SHIFT    24
#define MSIIR_IBS_MASK     (0x1f << MSIIR_IBS_SHIFT)

// Write callback for msi_reg memory range.
void IC_pv::cb_write_msi_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    int idx = opp->irq_msi;
    int srs, ibs;
    uint32_t val;
    union u
    {
      uint32_t val;
      char     array[sizeof(uint32_t)];
    }u;

    memcpy(u.array, data, length);
    val = u.val;

    //DPRINTF("%s: addr %#" HWADDR_PRIx " <= 0x%08" PRIx64 "\n",
    //            __func__, addr, val);
    if (address & 0xF) {
        return;
    }

    switch (address) {
    case MSIIR_OFFSET:
        srs = val >> MSIIR_SRS_SHIFT;
        idx += srs;
        ibs = (val & MSIIR_IBS_MASK) >> MSIIR_IBS_SHIFT;
        opp->msi[srs].msir |= 1 << ibs;
        openpic_set_irq(opp, idx, 1);
        break;
    default:
        /* most registers are read-only, thus ignored */
        break;
    }  
}

// Read callback for msi_reg memory range.
void IC_pv::cb_read_msi_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    uint64_t r = 0;
    int i, srs;

    //    DPRINTF("%s: addr %#" HWADDR_PRIx "\n", __func__, addr);
    if (address & 0xF) {
      //        return -1;
      abort();
    }

    srs = address >> 4;

    switch (address) {
    case 0x00:
    case 0x10:
    case 0x20:
    case 0x30:
    case 0x40:
    case 0x50:
    case 0x60:
    case 0x70: /* MSIRs */
        r = opp->msi[srs].msir;
        /* Clear on read */
        opp->msi[srs].msir = 0;
        openpic_set_irq(opp, opp->irq_msi + srs, 0);
        break;
    case 0x120: /* MSISR */
        for (i = 0; i < MAX_MSI; i++) {
            r |= (opp->msi[i].msir ? 1 : 0) << i;
        }
        break;
    }

    //    return r;
    memcpy(data, &r, length);
}
 

// Write callback for summary_reg memory range.
void IC_pv::cb_write_summary_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    /* TODO: EISR/EIMR */  
  abort();
}

// Read callback for summary_reg memory range.
void IC_pv::cb_read_summary_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    /* TODO: EISR/EIMR */
  abort();
}

#define ILR_INTTGT_MASK   0x000000ff
#define ILR_INTTGT_INT    0x00
#define ILR_INTTGT_CINT   0x01 /* critical */
#define ILR_INTTGT_MCP    0x02 /* machine check */

const int inttgt_output[][2] = {
    { ILR_INTTGT_INT, OPENPIC_OUTPUT_INT },
    { ILR_INTTGT_CINT, OPENPIC_OUTPUT_CINT },
    { ILR_INTTGT_MCP, OPENPIC_OUTPUT_MCK },
};
int IC_pv::output_to_inttgt(int output)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(inttgt_output); i++) {
        if (inttgt_output[i][1] == output) {
            return inttgt_output[i][0];
        }
    }

    abort();
}

int IC_pv::inttgt_to_output(int inttgt)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(inttgt_output); i++) {
        if (inttgt_output[i][0] == inttgt) {
            return inttgt_output[i][1];
        }
    }

    //    fprintf(stderr, "%s: unsupported inttgt %d\n", __func__, inttgt);
    return OPENPIC_OUTPUT_INT;
}

uint32_t IC_pv::read_IRQreg_ilr(OpenPICState *opp, int n_IRQ)
{
    if (opp->flags & OPENPIC_FLAG_ILR) {
        return output_to_inttgt(opp->src[n_IRQ].output);
    }

    return 0xffffffff;
}

void IC_pv::write_IRQreg_ilr(OpenPICState *opp, int n_IRQ, uint32_t val)
{
    if (opp->flags & OPENPIC_FLAG_ILR) {
        IRQSource *src = &opp->src[n_IRQ];

        src->output = inttgt_to_output(val & ILR_INTTGT_MASK);
        //        DPRINTF("Set ILR %d to 0x%08x, output %d\n", n_IRQ, src->idr,
        //                src->output);

        /* TODO: on MPIC v4.0 only, set nomask for non-INT */
    }
}



// Write callback for src_reg memory range.
void IC_pv::cb_write_src_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    int idx;
    uint32_t val;
    union u
    {
      uint32_t val;
      char     array[sizeof(uint32_t)];
    }u;

    memcpy(u.array, data, length);
    val = u.val;

    //    DPRINTF("%s: addr %#" HWADDR_PRIx " <= %08" PRIx64 "\n",
    //            __func__, addr, val);

    address = address & 0xffff;
    idx = address >> 5;

    switch (address & 0x1f) {
    case 0x00:
        write_IRQreg_ivpr(opp, idx, val);
        break;
    case 0x10:
        write_IRQreg_idr(opp, idx, val);
        break;
    case 0x18:
        write_IRQreg_ilr(opp, idx, val);
        break;
    }  
}

// Read callback for src_reg memory range.
void IC_pv::cb_read_src_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    uint32_t retval;
    int idx;

    //    DPRINTF("%s: addr %#" HWADDR_PRIx "\n", __func__, addr);
    retval = 0xFFFFFFFF;

    address = address & 0xffff;
    idx = address >> 5;

    switch (address & 0x1f) {
    case 0x00:
        retval = read_IRQreg_ivpr(opp, idx);
        break;
    case 0x10:
        retval = read_IRQreg_idr(opp, idx);
        break;
    case 0x18:
        retval = read_IRQreg_ilr(opp, idx);
        break;
    }

    //    DPRINTF("%s: => 0x%08x\n", __func__, retval);
    //    return retval;
    memcpy(data, &retval, length);
}
 

// Write callback for cpu_reg memory range.
void IC_pv::cb_write_cpu_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    uint32_t val;
    union u
    {
      uint32_t val;
      char     array[sizeof(uint32_t)];
    }u;

    memcpy(u.array, data, length);
    val = u.val;

    openpic_cpu_write_internal(opp, address, val, (address & 0x1f000) >> 12);
}

// Read callback for cpu_reg memory range.
void IC_pv::cb_read_cpu_reg(uint64_t address, unsigned char* data, unsigned length) {
    OpenPICState *opp = &OppState;
    uint32_t retval;
    retval = openpic_cpu_read_internal(opp, address, (address & 0x1f000) >> 12);  
    memcpy(data, &retval, length);
}
 
/**
 * set_bit - Set a bit in memory
 * @nr: the bit to set
 * @addr: the address to start counting from
 */

void IC_pv::set_bit(int32_t nr, uint32_t *addr)
{
	uint32_t mask = BIT_MASK(nr);
        uint32_t *p = addr + BIT_WORD(nr);

	*p  |= mask;
}

/**
 * clear_bit - Clears a bit in memory
 * @nr: Bit to clear
 * @addr: Address to start counting from
 */
void IC_pv::clear_bit(int32_t nr, uint32_t *addr)
{
	uint32_t mask = BIT_MASK(nr);
        uint32_t *p = addr + BIT_WORD(nr);

	*p &= ~mask;
}

/**
 * test_bit - Determine whether a bit is set
 * @nr: bit number to test
 * @addr: Address to start counting from
 */
int IC_pv::test_bit(int32_t nr, const uint32_t *addr)
{
	return 1U & (addr[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG-1)));
}

uint32_t IC_pv::find_next_bit(const uint32_t *addr, uint32_t size,
			    uint32_t offset)
{
    const uint32_t *p = addr + BITOP_WORD(offset);
    uint32_t result = offset & ~(BITS_PER_LONG-1);
    uint32_t tmp;

    if (offset >= size) {
        return size;
    }
    size -= result;
    offset %= BITS_PER_LONG;
    if (offset) {
        tmp = *(p++);
        tmp &= (~0U << offset);
        if (size < BITS_PER_LONG) {
            goto found_first;
        }
        if (tmp) {
            goto found_middle;
        }
        size -= BITS_PER_LONG;
        result += BITS_PER_LONG;
    }
    while (size >= 4*BITS_PER_LONG) {
        uint32_t d1, d2, d3;
        tmp = *p;
        d1 = *(p+1);
        d2 = *(p+2);
        d3 = *(p+3);
        if (tmp) {
            goto found_middle;
        }
        if (d1 | d2 | d3) {
            break;
        }
        p += 4;
        result += 4*BITS_PER_LONG;
        size -= 4*BITS_PER_LONG;
    }
    while (size >= BITS_PER_LONG) {
        if ((tmp = *(p++))) {
            goto found_middle;
        }
        result += BITS_PER_LONG;
        size -= BITS_PER_LONG;
    }
    if (!size) {
        return result;
    }
    tmp = *p;

found_first:
    tmp &= (~0U >> (BITS_PER_LONG - size));
    if (tmp == 0U) {		/* Are any bits set? */
        return result + size;	/* Nope. */
    }
found_middle:
    return result + mb::utl::ctz32(tmp); //TODON ask ALEX
}

/*
void IC_pv::qemu_set_irq(void *opaque, int level)
{
  qemu_irq irq = reinterpret_cast<qemu_irq>(opaque);
    if (!irq)
        return;

    irq->handler(irq->opaque, irq->n, level);
}
*/

void IC_pv::set_irq(int type, int level)
{
  switch (type)
  {
  case OPENPIC_OUTPUT_INT:
    //    cout << "int_n WRITING <<<<<< " << !level <<endl;
    int_n.write(!level);
    break;
  case OPENPIC_OUTPUT_CINT:
    //    cout << "cint_n WRITING <<<<<< " << !level <<endl;
    cint_n.write(!level);
    break;
  case OPENPIC_OUTPUT_MCK:
    //    cout << "mcp WRITING <<<<<< " << !level <<endl;
    mcp_n.write(!level);
    break;
  case OPENPIC_OUTPUT_DEBUG:
    abort();
    break;
  case OPENPIC_OUTPUT_RESET:
    //    cout << "reset_n WRITING <<<<<< " << !level <<endl;
    reset_n.write(!level);
    break;
  default:
    abort();
    break;    
  }
}


void IC_pv::IRQ_setbit(IRQQueue *q, int n_IRQ)
{
    set_bit(n_IRQ, q->queue);
}

void  IC_pv::IRQ_resetbit(IRQQueue *q, int n_IRQ)
{
    clear_bit(n_IRQ, q->queue);
}

int  IC_pv::IRQ_testbit(IRQQueue *q, int n_IRQ)
{
    return test_bit(n_IRQ, q->queue);
}

int IC_pv::IRQ_get_next(OpenPICState *opp, IRQQueue *q)
{
    /* XXX: optimize */
    IRQ_check(opp, q);

    return q->next;
}

void  IC_pv::IRQ_check(OpenPICState *opp, IRQQueue *q)
{
    int irq = -1;
    int next = -1;
    int priority = -1;

    for (;;) {
        irq = find_next_bit(q->queue, opp->max_irq, irq + 1);
        if (irq == opp->max_irq) {
            break;
        }

        //        DPRINTF("IRQ_check: irq %d set ivpr_pr=%d pr=%d\n",
        //                irq, IVPR_PRIORITY(opp->src[irq].ivpr), priority);

        if (IVPR_PRIORITY(opp->src[irq].ivpr) > priority) {
            next = irq;
            priority = IVPR_PRIORITY(opp->src[irq].ivpr);
        }
    }

    q->next = next;
    q->priority = priority;
}


void IC_pv::IRQ_local_pipe(OpenPICState *opp, int n_CPU, int n_IRQ,
                           bool active, bool was_active)
{
    IRQDest *dst;
    IRQSource *src;
    int priority;

    dst = &opp->dst[n_CPU];
    src = &opp->src[n_IRQ];

    //    DPRINTF("%s: IRQ %d active %d was %d\n",
    //            __func__, n_IRQ, active, was_active);

    if (src->output != OPENPIC_OUTPUT_INT) {
      //        DPRINTF("%s: output %d irq %d active %d was %d count %d\n",
      //                __func__, src->output, n_IRQ, active, was_active,
      //                dst->outputs_active[src->output]);

        /* On Freescale MPIC, critical interrupts ignore priority,
         * IACK, EOI, etc.  Before MPIC v4.1 they also ignore
         * masking.
         */
        if (active) {
            if (!was_active && dst->outputs_active[src->output]++ == 0) {
              //                DPRINTF("%s: Raise OpenPIC output %d cpu %d irq %d\n",
              //                        __func__, src->output, n_CPU, n_IRQ);
              //              qemu_set_irq(dst->irqs[src->output],1);
              set_irq(src->output, 1);
            }
        } else {
            if (was_active && --dst->outputs_active[src->output] == 0) {
              //                DPRINTF("%s: Lower OpenPIC output %d cpu %d irq %d\n",
              //                        __func__, src->output, n_CPU, n_IRQ);
              //              qemu_set_irq(dst->irqs[src->output],0);
              set_irq(src->output, 0);
            }
        }

        return;
    }

    priority = IVPR_PRIORITY(src->ivpr);

    /* Even if the interrupt doesn't have enough priority,
     * it is still raised, in case ctpr is lowered later.
     */
    if (active) {
        IRQ_setbit(&dst->raised, n_IRQ);
    } else {
        IRQ_resetbit(&dst->raised, n_IRQ);
    }

    IRQ_check(opp, &dst->raised);

    if (active && priority <= dst->ctpr) {
      //        DPRINTF("%s: IRQ %d priority %d too low for ctpr %d on CPU %d\n",
      //                __func__, n_IRQ, priority, dst->ctpr, n_CPU);
        active = 0;
    }

    if (active) {
        if (IRQ_get_next(opp, &dst->servicing) >= 0 &&
                priority <= dst->servicing.priority) {
          //            DPRINTF("%s: IRQ %d is hidden by servicing IRQ %d on CPU %d\n",
          //                    __func__, n_IRQ, dst->servicing.next, n_CPU);
        } else {
          //            DPRINTF("%s: Raise OpenPIC INT output cpu %d irq %d/%d\n",
          //                    __func__, n_CPU, n_IRQ, dst->raised.next);
          //            qemu_set_irq(opp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT],1);
          //instead..TODO verify            qemu_irq_raise(opp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT]);
          set_irq(OPENPIC_OUTPUT_INT, 1);
        }
    } else {
        IRQ_get_next(opp, &dst->servicing);
        if (dst->raised.priority > dst->ctpr &&
                dst->raised.priority > dst->servicing.priority) {
          //            DPRINTF("%s: IRQ %d inactive, IRQ %d prio %d above %d/%d, CPU %d\n",
          //                    __func__, n_IRQ, dst->raised.next, dst->raised.priority,
          //                    dst->ctpr, dst->servicing.priority, n_CPU);
            /* IRQ line stays asserted */
        } else {
      //            DPRINTF("%s: IRQ %d inactive, current prio %d/%d, CPU %d\n",
      //                    __func__, n_IRQ, dst->ctpr, dst->servicing.priority, n_CPU);
          //            qemu_set_irq(opp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT],0);
          set_irq(OPENPIC_OUTPUT_INT, 0);
            //instead..TODO verify            qemu_irq_lower(opp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT]);
        }
    }
}

/* update pic state because registers for n_IRQ have changed value */
void  IC_pv::openpic_update_irq(OpenPICState *opp, int n_IRQ)
{
    IRQSource *src;
    bool active, was_active;
    int i;

    src = &opp->src[n_IRQ];
    active = src->pending;

    if ((src->ivpr & IVPR_MASK_MASK) && !src->nomask) {
        /* Interrupt source is disabled */
      //        DPRINTF("%s: IRQ %d is disabled\n", __func__, n_IRQ);
        active = false;
    }

    was_active = !!(src->ivpr & IVPR_ACTIVITY_MASK);

    /*
     * We don't have a similar check for already-active because
     * ctpr may have changed and we need to withdraw the interrupt.
     */
    if (!active && !was_active) {
      //        DPRINTF("%s: IRQ %d is already inactive\n", __func__, n_IRQ);
        return;
    }

    if (active) {
        src->ivpr |= IVPR_ACTIVITY_MASK;
    } else {
        src->ivpr &= ~IVPR_ACTIVITY_MASK;
    }

    if (src->destmask == 0) {
        /* No target */
      //        DPRINTF("%s: IRQ %d has no target\n", __func__, n_IRQ);
        return;
    }

    if (src->destmask == (1 << src->last_cpu)) {
        /* Only one CPU is allowed to receive this IRQ */
        IRQ_local_pipe(opp, src->last_cpu, n_IRQ, active, was_active);
    } else if (!(src->ivpr & IVPR_MODE_MASK)) {
        /* Directed delivery mode */
        for (i = 0; i < opp->nb_cpus; i++) {
            if (src->destmask & (1 << i)) {
                IRQ_local_pipe(opp, i, n_IRQ, active, was_active);
            }
        }
    } else {
        /* Distributed delivery mode */
        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {
            if (i == opp->nb_cpus) {
                i = 0;
            }
            if (src->destmask & (1 << i)) {
                IRQ_local_pipe(opp, i, n_IRQ, active, was_active);
                src->last_cpu = i;
                break;
            }
        }
    }
}


void  IC_pv::openpic_set_irq(void *opaque, int n_IRQ, int level)
{
    OpenPICState *opp = reinterpret_cast<OpenPICState *>(opaque);
    IRQSource *src;

    if (n_IRQ >= OPENPIC_MAX_IRQ) {
      //        fprintf(stderr, "%s: IRQ %d out of range\n", __func__, n_IRQ);
      //        abort();
    }

    src = &opp->src[n_IRQ];
    //    DPRINTF("openpic: set irq %d = %d ivpr=0x%08x\n",
    //            n_IRQ, level, src->ivpr);
    if (src->level) {
        /* level-sensitive irq */
        src->pending = level;
        openpic_update_irq(opp, n_IRQ);
    } else {
        /* edge-sensitive irq */
        if (level) {
            src->pending = 1;
            openpic_update_irq(opp, n_IRQ);
        }

        if (src->output != OPENPIC_OUTPUT_INT) {
            /* Edge-triggered interrupts shouldn't be used
             * with non-INT delivery, but just in case,
             * try to make it do something sane rather than
             * cause an interrupt storm.  This is close to
             * what you'd probably see happen in real hardware.
             */
            src->pending = 0;
            openpic_update_irq(opp, n_IRQ);
        }
    }
}


void IC_pv::openpic_gcr_write(OpenPICState *opp, uint64_t val)
{
    bool mpic_proxy = false;

    if (val & GCR_RESET) {
      //openpic_reset(DEVICE(opp));
      reset_n.write(false);
      return;
    }

    opp->gcr &= ~opp->mpic_mode_mask;
    opp->gcr |= val & opp->mpic_mode_mask;

    /* Set external proxy mode */
    if ((val & opp->mpic_mode_mask) == GCR_MODE_PROXY) {
           mpic_proxy = true;
    }

    //    ppce500_set_mpic_proxy(mpic_proxy);
}

// Write callback for mpic_global_slave port.
// Returns true when successful.

/* interprocessor interrupt dispatch - to deal later with adequate ports*/
//void IC_pv::openpic_set_irq(OpenPICState *opp, int n_IRQ, int level);


void  IC_pv::openpic_cpu_write_internal(OpenPICState *opp, uint64_t addr,
                                       uint32_t val, int idx)
{
    IRQSource *src;
    IRQDest *dst;
    int s_IRQ, n_IRQ;

    //    DPRINTF("%s: cpu %d addr %#" UINT64_T_PRIx " <= 0x%08x\n", __func__, idx,
    //            addr, val);

    if (idx < 0) {
        return;
    }

    if (addr & 0xF) {
        return;
    }
    dst = &opp->dst[idx];
    addr &= 0xFF0;
    switch (addr) {
    case 0x40: /* IPIDR */
    case 0x50:
    case 0x60:
    case 0x70://TODO
      //        idx = (addr - 0x40) >> 4;
        /* we use IDE as mask which CPUs to deliver the IPI to still. */
      //        opp->src[opp->irq_ipi0 + idx].destmask |= val;
        openpic_set_irq(opp, opp->irq_ipi0 + idx, 1);
        openpic_set_irq(opp, opp->irq_ipi0 + idx, 0);
        break;
    case 0x80: /* CTPR - Current task priority register*/ //0x4_0080, 0x6_0080, 0x6_0180, 0x6_0280, 0x6_0380
      /*one for each CPU and ageneral one relevant for internal interrupts only, general probably not in use*/
        dst->ctpr = val & 0x0000000F;

        //        DPRINTF("%s: set CPU %d ctpr to %d, raised %d servicing %d\n",
        //                __func__, idx, dst->ctpr, dst->raised.priority,
        //                dst->servicing.priority);

        if (dst->raised.priority <= dst->ctpr) {
          //            DPRINTF("%s: Lower OpenPIC INT output cpu %d due to ctpr\n",
          //                    __func__, idx);
          //            qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_INT]);
          //          qemu_set_irq(dst->irqs[OPENPIC_OUTPUT_INT],0);
          set_irq(OPENPIC_OUTPUT_INT, 0);
          
          
        } else if (dst->raised.priority > dst->servicing.priority) {
          //  DPRINTF("%s: Raise OpenPIC INT output cpu %d irq %d\n",
          //                    __func__, idx, dst->raised.next);
          //  qemu_irq_raise(dst->irqs[OPENPIC_OUTPUT_INT]);
          //          qemu_set_irq(dst->irqs[OPENPIC_OUTPUT_INT],1);
          set_irq(OPENPIC_OUTPUT_INT, 1);
        }

        break;
    case 0x90: /* WHOAMI */
        /* Read-only register */
        break;
    case 0xA0: /* IACK */
        /* Read-only register */
        break;
    case 0xB0: /* EOI */
      //        DPRINTF("EOI\n");
        s_IRQ = IRQ_get_next(opp, &dst->servicing);

        if (s_IRQ < 0) {
          //            DPRINTF("%s: EOI with no interrupt in service\n", __func__);
            break;
        }

        IRQ_resetbit(&dst->servicing, s_IRQ);
        /* Set up next servicing IRQ */
        s_IRQ = IRQ_get_next(opp, &dst->servicing);
        /* Check queued interrupts. */
        n_IRQ = IRQ_get_next(opp, &dst->raised);
        src = &opp->src[n_IRQ];
        if (n_IRQ != -1 &&
            (s_IRQ == -1 ||
             IVPR_PRIORITY(src->ivpr) > dst->servicing.priority)) {
          //    DPRINTF("Raise OpenPIC INT output cpu %d irq %d\n",
          //                    idx, n_IRQ);
          //            qemu_set_irq(opp->dst[idx].irqs[OPENPIC_OUTPUT_INT],1);
          set_irq(OPENPIC_OUTPUT_INT, 1);
            //         qemu_irq_raise(opp->dst[idx].irqs[OPENPIC_OUTPUT_INT]);
        }
        break;
    default:
        break;
    }
}
int IC_pv::get_current_cpu(void)
{
  return 0;//TODON
  /*    if (!current_cpu) {
        return -1;
    }

    return current_cpu->cpu_index;
  */
}
void IC_pv::write_IRQreg_idr(OpenPICState *opp, int n_IRQ, uint32_t val)
{
    IRQSource *src = &opp->src[n_IRQ];
    uint32_t normal_mask = (1U << opp->nb_cpus) - 1;
    uint32_t crit_mask = 0;
    uint32_t mask = normal_mask;
    int crit_shift = IDR_EP_SHIFT - opp->nb_cpus;
    int i;

    if (opp->flags & OPENPIC_FLAG_IDR_CRIT) {
        crit_mask = mask << crit_shift;
        mask |= crit_mask | IDR_EP;
    }

    src->idr = val & mask;
    //    DPRINTF("Set IDR %d to 0x%08x\n", n_IRQ, src->idr);

    if (opp->flags & OPENPIC_FLAG_IDR_CRIT) {
        if (src->idr & crit_mask) {
            if (src->idr & normal_mask) {
              //          DPRINTF("%s: IRQ configured for multiple output types, using "
              //                        "critical\n", __func__);
            }

            src->output = OPENPIC_OUTPUT_CINT;
            src->nomask = true;
            src->destmask = 0;

            for (i = 0; i < opp->nb_cpus; i++) {
                int n_ci = IDR_CI0_SHIFT - i;

                if (src->idr & (1U << n_ci)) {
                    src->destmask |= 1U << i;
                }
            }
        } else {
            src->output = OPENPIC_OUTPUT_INT;
            src->nomask = false;
            src->destmask = src->idr & normal_mask;
        }
    } else {
        src->destmask = src->idr;
    }
}


void IC_pv::write_IRQreg_ivpr(OpenPICState *opp, int n_IRQ, uint32_t val)
{
    uint32_t mask;

    /* NOTE when implementing newer FSL MPIC models: starting with v4.0,
     * the polarity bit is read-only on internal interrupts.
     */
    mask = IVPR_MASK_MASK | IVPR_PRIORITY_MASK | IVPR_SENSE_MASK |
           IVPR_POLARITY_MASK | opp->vector_mask;

    /* ACTIVITY bit is read-only */
    opp->src[n_IRQ].ivpr =
        (opp->src[n_IRQ].ivpr & IVPR_ACTIVITY_MASK) | (val & mask);

    /* For FSL internal interrupts, The sense bit is reserved and zero,
     * and the interrupt is always level-triggered.  Timers and IPIs
     * have no sense or polarity bits, and are edge-triggered.
     */
    switch (opp->src[n_IRQ].type) {
    case IRQ_TYPE_NORMAL:
        opp->src[n_IRQ].level = !!(opp->src[n_IRQ].ivpr & IVPR_SENSE_MASK);
        break;

    case IRQ_TYPE_FSLINT:
        opp->src[n_IRQ].ivpr &= ~IVPR_SENSE_MASK;
        break;

    case IRQ_TYPE_FSLSPECIAL:
        opp->src[n_IRQ].ivpr &= ~(IVPR_POLARITY_MASK | IVPR_SENSE_MASK);
        break;
    }

    openpic_update_irq(opp, n_IRQ);
    //DPRINTF("Set IVPR %d to 0x%08x -> 0x%08x\n", n_IRQ, val,
    //            opp->src[n_IRQ].ivpr);
}


bool IC_pv::bus_slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {

  if (size != sizeof(uint32_t))
    abort();

  //  std::string binary = std::bitset<32>((uint32_t) *data).to_string(); //to binary
  //  cout << name() << " @ " << sc_time_stamp() << " write " << address << " with " << hex << ((uint32_t) *data) << " bin: " << binary << endl;

  if (address < OPENPIC_TMR_REG_START){
    cb_write_global_reg(address, data, size);
  }else if (address < OPENPIC_MSI_REG_START){
    cb_write_tmr_reg(address - OPENPIC_TMR_REG_START, data, size);
  }else if (address < OPENPIC_SUMMARY_REG_START){
    cb_write_msi_reg(address - OPENPIC_MSI_REG_START, data, size);
  }else if (address < OPENPIC_SRC_REG_START){
    cb_write_summary_reg(address - OPENPIC_SUMMARY_REG_START, data, size);
  }else if (address < OPENPIC_CPU_REG_START){
    cb_write_src_reg(address - OPENPIC_SRC_REG_START, data, size);
  }else if (address < OPENPIC_CPU_REG_START+OPENPIC_CPU_REG_SIZE){
    cb_write_cpu_reg(address - OPENPIC_CPU_REG_START, data, size);
  }else{
    return false;
  }
  return true;
} 
bool IC_pv::bus_slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {

  if (size != sizeof(uint32_t))
    abort();
  
  if (address < OPENPIC_TMR_REG_START){
    cb_read_global_reg(address, data, size);
  }else if (address < OPENPIC_MSI_REG_START){
    cb_read_tmr_reg(address - OPENPIC_TMR_REG_START, data, size);
  }else if (address < OPENPIC_SUMMARY_REG_START){
    cb_read_msi_reg(address - OPENPIC_MSI_REG_START, data, size);
  }else if (address < OPENPIC_SRC_REG_START){
    cb_read_summary_reg(address - OPENPIC_SUMMARY_REG_START, data, size);
  }else if (address < OPENPIC_CPU_REG_START){
    cb_read_src_reg(address - OPENPIC_SRC_REG_START, data, size);
  }else if (address < OPENPIC_CPU_REG_START+OPENPIC_CPU_REG_SIZE){
    cb_read_cpu_reg(address - OPENPIC_CPU_REG_START, data, size);
  }else{
    return false;
  }
  return true;
} 


unsigned IC_pv::bus_slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool IC_pv::bus_slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}


// callback for any change in signal: EIRQ0 of type: sc_in<bool>
void IC_pv::EIRQ0_callback() {
}

// callback for any change in signal: Internal0 of type: sc_in<bool>
void IC_pv::Internal0_callback() {
  //0x35 including external 16+37
  bool level = Internal0.read()?1:0;
  if (!OppState.src[0x35].nomask )
    OppState.src[0x35].nomask = true;
  openpic_set_irq(&OppState, 0x35, level);  
}

// callback for any change in signal: Internal1 of type: sc_in<bool>
void IC_pv::Internal1_callback() {
  //  openpic_set_irq(&OppState, 0x25, Internal1.read());  
  bool level = Internal1.read()?1:0;

  if (!OppState.src[0x36].nomask )
    OppState.src[0x36].nomask = true;
  openpic_set_irq(&OppState, 0x36, level);  
}

// callback for any change in signal: Internal2 of type: sc_in<bool>
void IC_pv::Internal2_callback() {
  openpic_set_irq(&OppState, 0x26, Internal2.read());  
}

// callback for any change in signal: Internal3 of type: sc_in<bool>
void IC_pv::Internal3_callback() {
  openpic_set_irq(&OppState, 0x27, Internal3.read());  
}

// callback for any change in signal: Internal4 of type: sc_in<bool>
void IC_pv::Internal4_callback() {
  OppState.src[0x28].level = false;
  openpic_set_irq(&OppState, 0x28, Internal4.read());  
}

// in order to minimize merging conflicts, we recommend to add your functions after this comment
