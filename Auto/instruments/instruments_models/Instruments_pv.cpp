
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for Instruments.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.1beta2
//* Generated on: Apr. 17, 2015 02:47:16 PM, (user: markca)
//*>



#include "Instruments_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
Instruments_pv::Instruments_pv(sc_module_name module_name) 
  : Instruments_pv_base(module_name)
#ifdef __VISTA_OSCI23__
  ,safe_ev("safe_ev")
#endif
{
  int r;
  /* First call to socket() function */
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0) 
    {
      perror("ERROR opening socket");
      exit(1);
    }
  /* Initialize socket structure */
  bzero((char *) &serv_addr, sizeof(serv_addr));
  portno = 5005;
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = INADDR_ANY;
  serv_addr.sin_port = htons(portno);
  int yes = 1;
  if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
    perror("setsockopt");
    exit(1);
  }

  /* Now bind the host address using bind() call.*/
  if (bind(sockfd, (struct sockaddr *) &serv_addr,
           sizeof(serv_addr)) < 0) {
    perror("ERROR on binding");
      exit(0);
  }
  
  child_pid = 0;
  if((child_pid = fork()) < 0 )  {
    perror("fork failure");
    exit(1);
  }
  if(child_pid == 0) {
    execl("instruments.py", "instruments.py", (char*) 0);
    perror("execl() failure!\n\n");
    _exit(1);
  }
  
  /* Now start listening for the clients, here process will
   * go in sleep mode and will wait for the incoming connection
   */
  listen(sockfd,5);
  clilen = sizeof(cli_addr);

  cout << "Instruments: Awaiting connection from GUI on port 5005" << endl;

  /* Accept actual connection from the client */
  newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
  if (newsockfd < 0) 
    {
      perror("ERROR on accept");
      exit(0);
    }
  
  SC_THREAD(input);

  r = pthread_create( &readerThread, NULL, &Instruments_pv::call_startReader, this);
  if (r ==0) pthread_detach(readerThread);
}    

// Destructor cleans up the forked python script
Instruments_pv::~Instruments_pv()
{
  if(child_pid) { 
    cout << "Instruments: Sending kill signal to forked Python script" << endl;
    kill(child_pid, SIGKILL);
    child_pid = 0;
  }
}

// SystemC process which waits for asynchronous input from external process
void Instruments_pv::input() {
  InstrumentsDataType *data;

  while (1) {
#ifdef __VISTA_OSCI23__
    wait(safe_ev.default_event());  	// Waits for data from startReader pthread
#else
    wait();
#endif

    // To safely pass data a mutex must be used between startReader and input 
    // protecting each process' modifications of the shared q
    pthread_mutex_lock(&mutex);		
    while (q.size()) {
      data = q.front();		// get the data from the q
      q.pop_front();
      switch(data->id) {
      case 0x0:
        //        cout << "Instruments: Accelerator = " << std::dec << data->value << endl;
        acceleratorFifo.nb_put(data->value);
        break;
      case 0x1:
        //        cout << "Instruments: Brake = " << std::dec << data->value << endl;
        brakeFifo.nb_put(data->value);
        break;
      default:
        cout << "Instruments: [WARNING] Unidentifed data received, ignoring" << endl;
        break;
      }
      delete(data);
    }
    pthread_mutex_unlock(&mutex);  // After all data is read from the q release the mutex
  }
}
 
// C++ pthread which will read the socket and wait for input
// from the external process.  It will forward and call notify on safe_ev
void *Instruments_pv::startReader(void) {
  char buffer[256];
  uint id;
  uint v;
  uint t;
  InstrumentsDataType *data;
  
  /* If connection is established then start communicating */
  ssize_t bytes_read;
  cout << "Instruments: GUI connected, awaiting commands" << endl;
  while(1) {
    do {
        bzero(buffer, 256);
        bytes_read = recv(newsockfd, buffer, sizeof(buffer), 0);
        if (bytes_read > 0) {
          string cmd(buffer);
          id = buffer[0];
          v = buffer[4];
          data = new InstrumentsDataType();	// Create new data structure then fill in values
          data->id = id;
          data->value = v;
          pthread_mutex_lock(&mutex);	// Use mutex to safely modify q
          q.push_back(data);
#ifdef __VISTA_OSCI23__
          safe_ev.notify();			// input SystemC thread is waiting on safe_ev
#else
          cout << "Instruments: [Error] GUI input requires SystemC 2.3" << endl;
#endif
          pthread_mutex_unlock(&mutex);	// Release mutex when done modifying q
        } else if(bytes_read == 0) {
          cout << "Instruments: GUI disconnected, ending simulation" << endl;
          if(child_pid) {
            child_pid = 0;
            sc_stop();
          }
          return 0;
        }
      } while (bytes_read > 0);
  }
  return 0;
}
