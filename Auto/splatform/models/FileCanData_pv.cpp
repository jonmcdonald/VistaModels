
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for FileCanData.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.9.0
//* Generated on: Mar. 31, 2015 03:29:10 PM, (user: jon)
//* Automatically merged on: May. 12, 2015 06:43:07 PM, (user: jon)
//*>



#include "FileCanData_pv.h"
#include "MemoryMap.h"


using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
FileCanData_pv::FileCanData_pv(sc_module_name module_name) 
  : FileCanData_pv_base(module_name),
    inff(NULL)
{
  string fname("data/");
  fname.append(name());
  ifile.open(fname.c_str(), std::ifstream::in);

  SC_THREAD(file_thread);
  SC_THREAD(fifo_thread);
}    

// Read callback for rxi port.
// Returns true when successful.
bool FileCanData_pv::rxi_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Write callback for rxi port.
// Returns true when successful.
bool FileCanData_pv::rxi_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  unsigned long long l_data;
  mb::mb_token_ptr tokenptr = get_current_token();
  double nstime;

  if (*data == 1) {
    m_write(CAN_ACK, 0);        // ack reg
    m_read(CAN_RXSIZE, m_size);      // length
    m_read(CAN_RXIDENT, m_ident);    // ident
    l_data = 0;
    if (m_size > 0) {
      m_read(CAN_RXDATA, (unsigned char *) &l_data, m_size); // RX data
      m_data = l_data;
    }

    if (tokenptr && tokenptr->hasField("CreationTime")) {
      nstime = (sc_time_stamp() - tokenptr->getFieldAsTime("CreationTime")) / sc_time(1, SC_NS);
      LifeTime_usec = nstime / 1000.0;
    } else {
      cout << sc_time_stamp() << ": " << name() << ", received token with no CreationTime\n";
    }
    if (PRINT_MESSAGE && (m_ident == SPEEDID || m_ident == RPMID))
      cout << sc_time_stamp() <<": "<< name() << ", received 0x"<<hex<< m_ident<<dec<< ", "<< m_size << ", "
           << hex <<" 0x"<< l_data << dec << endl;
  }
  return true;
} 




unsigned FileCanData_pv::rxi_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned FileCanData_pv::rxi_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool FileCanData_pv::rxi_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

// callback for any change in signal: rxi of type: sc_in<bool>
void FileCanData_pv::m_rxi_callback() {
/*
  unsigned long long data;
  mb::mb_token_ptr tokenptr = get_current_token();
  double nstime;

  if (rxi.read() == 1) {
    m_write(CAN_ACK, 0);        // ack reg
    m_read(CAN_RXSIZE, m_size);      // length
    m_read(CAN_RXIDENT, m_ident);    // ident
    data = 0;
    if (m_size > 0) {
      m_read(CAN_RXDATA, (unsigned char *) &data, m_size); // RX data
      m_data = data;
    }

    if (tokenptr && tokenptr->hasField("CreationTime")) {
      nstime = (sc_time_stamp() - tokenptr->getFieldAsTime("CreationTime")) / sc_time(1, SC_NS);
      LifeTime_usec = nstime / 1000.0;
    } else {
      cout << sc_time_stamp() << ": " << name() << ", received token with no CreationTime\n";
    }
    if (PRINT_MESSAGE && (m_ident == SPEEDID || m_ident == RPMID))
      cout << sc_time_stamp() <<": "<< name() << ", received 0x"<<hex<< m_ident<<dec<< ", "<< m_size << ", "
           << hex <<" 0x"<< data << dec << endl;
  }
*/
}

void FileCanData_pv::fifo_thread() {
  unsigned int data_32;

  if (inff != NULL) {
    while (1) {
      data_32 = inff->get();
      while (inff->nb_can_get())
        data_32 = inff->get();
      m_write(CAN_SIZE, 4);
      m_write(CAN_RTR, 0);
      m_write(CAN_IDE, 1);
      m_write(CAN_DATA, data_32);
      m_write(CAN_IDENT, P_IDENT);
    }
  }
}

void FileCanData_pv::file_thread() {
  string s;
  unsigned int t_us, ident, size, rtr, ide;
  unsigned long long data;
  sc_time ctime = sc_time_stamp();
  mb::mb_token_ptr tokenptr;

  ifile >> s;
  while (ifile.good()) {
    if (s[0] == '#') {
      getline(ifile, s);
      ifile >> s;
    } else {
      ifile >> dec >> t_us >> hex >> ident >> size >> rtr >> ide >> data;
      cout <<sc_time_stamp()<<": "<<name()<<", "<< dec << t_us<<" 0x"<<hex<<ident<<" "<<size<<" "<<rtr<<" "<<ide<<" 0x"<<data<<endl;
      ifile >> s;

      ctime = sc_time_stamp();
      if (ctime < sc_time(t_us, SC_US))
        wait(sc_time(t_us, SC_US) - ctime);

      tokenptr = new mb::mb_token();
      tokenptr->setField("CreationTime", sc_time_stamp());
      set_current_token(tokenptr);
      m_write(CAN_SIZE, size);
      m_write(CAN_RTR, rtr);
      m_write(CAN_IDE, ide);
      m_write(CAN_DATA, (unsigned char *) &data, size);
      m_write(CAN_IDENT, ident);
    }
  }
}

 
